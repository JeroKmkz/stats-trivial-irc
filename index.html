<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Procesador de Logs de Trivial IRC ‚Äî Liga (estanca) + GP</title>
  <script src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; }
    .container { background-color: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    h1 { color: #333; text-align: center; margin-bottom: 30px; }
    .upload-section { border: 2px dashed #ddd; padding: 40px; text-align: center; margin-bottom: 30px; border-radius: 8px; background-color: #fafafa; }
    .upload-section:hover { border-color: #007bff; background-color: #f0f8ff; }
    input[type="file"] { margin: 20px 0; }
    .button { background-color: #007bff; color: white; padding: 12px 25px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; margin: 10px; }
    .button:hover { background-color: #0056b3; }
    .button:disabled { background-color: #ccc; cursor: not-allowed; }
    .results { margin-top: 30px; }
    .error { color: #dc3545; background-color: #f8d7da; padding: 15px; border-radius: 5px; margin: 20px 0; }
    .success { color: #155724; background-color: #d4edda; padding: 15px; border-radius: 5px; margin: 20px 0; }
    .log-info { background-color: #e9ecef; padding: 15px; border-radius: 5px; margin: 20px 0; }
    .competition-select { text-align: center; margin-bottom: 30px; display:flex; gap:12px; justify-content:center; align-items:center; flex-wrap:wrap; }
    .competition-select label { font-weight: bold; margin-right: 6px; }
    select { padding: 6px 10px; font-size: 14px; }
    #gpRoundBox { display:none; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéØ Procesador de Logs de Trivial IRC</h1>

    <!-- SELECCI√ìN DE COMPETICI√ìN -->
    <div class="competition-select">
      <label for="competitionSelect">Tipo de competici√≥n:</label>
      <select id="competitionSelect">
        <option value="liga" selected>Liga</option>
        <option value="gp">GP</option>
        <option value="copa">Copa</option>
        <option value="relevos">Torneo Relevos</option>
        <option value="master">M√°ster por Equipos</option>
        <option value="posiciones" disabled>Torneo Posiciones (pr√≥x.)</option>
      </select>

      <!-- Selector de jornada GP (visible solo en GP) -->
      <span id="gpRoundBox">
        <label for="gpRoundSelect">Jornada GP:</label>
        <select id="gpRoundSelect">
          <option value="1" selected>GP1</option>
          <option value="2">GP2</option>
          <option value="3">GP3</option>
          <option value="4">GP4</option>
          <option value="5">GP5</option>
          <option value="final">FINAL</option>
        </select>
        
        <label for="gpThemeSelect" style="margin-left: 20px;">Tem√°tica:</label>
        <select id="gpThemeSelect">
          <option value="">Seleccionar tem√°tica...</option>
          <option value="Arte">Arte</option>
          <option value="Biolog√≠a">Biolog√≠a</option>
          <option value="Ciencia">Ciencia</option>
          <option value="Cine">Cine</option>
          <option value="Cotilleo-TV">Cotilleo-TV</option>
          <option value="Deporte">Deporte</option>
          <option value="Econom√≠a">Econom√≠a</option>
          <option value="Eros-Sex">Eros-Sex</option>
          <option value="Filosof√≠a">Filosof√≠a</option>
          <option value="F√≠sica-Qu√≠mica">F√≠sica-Qu√≠mica</option>
          <option value="Gastronom√≠a">Gastronom√≠a</option>
          <option value="Geograf√≠a">Geograf√≠a</option>
          <option value="Historia">Historia</option>
          <option value="Idiomas">Idiomas</option>
          <option value="Inform√°tica">Inform√°tica</option>
          <option value="Literatura">Literatura</option>
          <option value="Medicina-Salud">Medicina-Salud</option>
          <option value="Miscel√°nea">Miscel√°nea</option>
          <option value="Mitolog√≠a">Mitolog√≠a</option>
          <option value="M√∫sica">M√∫sica</option>
          <option value="Personajes">Personajes</option>
          <option value="Pol√≠tica">Pol√≠tica</option>
        </select>
      </span>

    <!-- Selector m√∫ltiple de tem√°ticas para FINAL (oculto por defecto) -->
        <div id="gpFinalThemesBox" style="display: none; margin-top: 15px;">
          <h4 style="margin: 10px 0;">Selecciona las 5 tem√°ticas para la FINAL (en orden):</h4>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; max-width: 600px;">
            <div>
              <label for="gpFinalTheme1">1¬™ Tem√°tica (GP1):</label>
              <select id="gpFinalTheme1">
                <option value="">Seleccionar...</option>
                <option value="Arte">Arte</option>
                <option value="Biolog√≠a">Biolog√≠a</option>
                <option value="Ciencia">Ciencia</option>
                <option value="Cine">Cine</option>
                <option value="Cotilleo-TV">Cotilleo-TV</option>
                <option value="Deporte">Deporte</option>
                <option value="Econom√≠a">Econom√≠a</option>
                <option value="Eros-Sex">Eros-Sex</option>
                <option value="Filosof√≠a">Filosof√≠a</option>
                <option value="F√≠sica-Qu√≠mica">F√≠sica-Qu√≠mica</option>
                <option value="Gastronom√≠a">Gastronom√≠a</option>
                <option value="Geograf√≠a">Geograf√≠a</option>
                <option value="Historia">Historia</option>
                <option value="Idiomas">Idiomas</option>
                <option value="Inform√°tica">Inform√°tica</option>
                <option value="Literatura">Literatura</option>
                <option value="Medicina-Salud">Medicina-Salud</option>
                <option value="Miscel√°nea">Miscel√°nea</option>
                <option value="Mitolog√≠a">Mitolog√≠a</option>
                <option value="M√∫sica">M√∫sica</option>
                <option value="Personajes">Personajes</option>
                <option value="Pol√≠tica">Pol√≠tica</option>
              </select>
            </div>
            <div>
              <label for="gpFinalTheme2">2¬™ Tem√°tica (GP2):</label>
              <select id="gpFinalTheme2">
                <option value="">Seleccionar...</option>
                <option value="Arte">Arte</option>
                <option value="Biolog√≠a">Biolog√≠a</option>
                <option value="Ciencia">Ciencia</option>
                <option value="Cine">Cine</option>
                <option value="Cotilleo-TV">Cotilleo-TV</option>
                <option value="Deporte">Deporte</option>
                <option value="Econom√≠a">Econom√≠a</option>
                <option value="Eros-Sex">Eros-Sex</option>
                <option value="Filosof√≠a">Filosof√≠a</option>
                <option value="F√≠sica-Qu√≠mica">F√≠sica-Qu√≠mica</option>
                <option value="Gastronom√≠a">Gastronom√≠a</option>
                <option value="Geograf√≠a">Geograf√≠a</option>
                <option value="Historia">Historia</option>
                <option value="Idiomas">Idiomas</option>
                <option value="Inform√°tica">Inform√°tica</option>
                <option value="Literatura">Literatura</option>
                <option value="Medicina-Salud">Medicina-Salud</option>
                <option value="Miscel√°nea">Miscel√°nea</option>
                <option value="Mitolog√≠a">Mitolog√≠a</option>
                <option value="M√∫sica">M√∫sica</option>
                <option value="Personajes">Personajes</option>
                <option value="Pol√≠tica">Pol√≠tica</option>
              </select>
            </div>
            <div>
              <label for="gpFinalTheme3">3¬™ Tem√°tica (GP3):</label>
              <select id="gpFinalTheme3">
                <option value="">Seleccionar...</option>
                <option value="Arte">Arte</option>
                <option value="Biolog√≠a">Biolog√≠a</option>
                <option value="Ciencia">Ciencia</option>
                <option value="Cine">Cine</option>
                <option value="Cotilleo-TV">Cotilleo-TV</option>
                <option value="Deporte">Deporte</option>
                <option value="Econom√≠a">Econom√≠a</option>
                <option value="Eros-Sex">Eros-Sex</option>
                <option value="Filosof√≠a">Filosof√≠a</option>
                <option value="F√≠sica-Qu√≠mica">F√≠sica-Qu√≠mica</option>
                <option value="Gastronom√≠a">Gastronom√≠a</option>
                <option value="Geograf√≠a">Geograf√≠a</option>
                <option value="Historia">Historia</option>
                <option value="Idiomas">Idiomas</option>
                <option value="Inform√°tica">Inform√°tica</option>
                <option value="Literatura">Literatura</option>
                <option value="Medicina-Salud">Medicina-Salud</option>
                <option value="Miscel√°nea">Miscel√°nea</option>
                <option value="Mitolog√≠a">Mitolog√≠a</option>
                <option value="M√∫sica">M√∫sica</option>
                <option value="Personajes">Personajes</option>
                <option value="Pol√≠tica">Pol√≠tica</option>
              </select>
            </div>
            <div>
              <label for="gpFinalTheme4">4¬™ Tem√°tica (GP4):</label>
              <select id="gpFinalTheme4">
                <option value="">Seleccionar...</option>
                <option value="Arte">Arte</option>
                <option value="Biolog√≠a">Biolog√≠a</option>
                <option value="Ciencia">Ciencia</option>
                <option value="Cine">Cine</option>
                <option value="Cotilleo-TV">Cotilleo-TV</option>
                <option value="Deporte">Deporte</option>
                <option value="Econom√≠a">Econom√≠a</option>
                <option value="Eros-Sex">Eros-Sex</option>
                <option value="Filosof√≠a">Filosof√≠a</option>
                <option value="F√≠sica-Qu√≠mica">F√≠sica-Qu√≠mica</option>
                <option value="Gastronom√≠a">Gastronom√≠a</option>
                <option value="Geograf√≠a">Geograf√≠a</option>
                <option value="Historia">Historia</option>
                <option value="Idiomas">Idiomas</option>
                <option value="Inform√°tica">Inform√°tica</option>
                <option value="Literatura">Literatura</option>
                <option value="Medicina-Salud">Medicina-Salud</option>
                <option value="Miscel√°nea">Miscel√°nea</option>
                <option value="Mitolog√≠a">Mitolog√≠a</option>
                <option value="M√∫sica">M√∫sica</option>
                <option value="Personajes">Personajes</option>
                <option value="Pol√≠tica">Pol√≠tica</option>
              </select>
            </div>
            <div>
              <label for="gpFinalTheme5">5¬™ Tem√°tica (GP5):</label>
              <select id="gpFinalTheme5">
                <option value="">Seleccionar...</option>
                <option value="Arte">Arte</option>
                <option value="Biolog√≠a">Biolog√≠a</option>
                <option value="Ciencia">Ciencia</option>
                <option value="Cine">Cine</option>
                <option value="Cotilleo-TV">Cotilleo-TV</option>
                <option value="Deporte">Deporte</option>
                <option value="Econom√≠a">Econom√≠a</option>
                <option value="Eros-Sex">Eros-Sex</option>
                <option value="Filosof√≠a">Filosof√≠a</option>
                <option value="F√≠sica-Qu√≠mica">F√≠sica-Qu√≠mica</option>
                <option value="Gastronom√≠a">Gastronom√≠a</option>
                <option value="Geograf√≠a">Geograf√≠a</option>
                <option value="Historia">Historia</option>
                <option value="Idiomas">Idiomas</option>
                <option value="Inform√°tica">Inform√°tica</option>
                <option value="Literatura">Literatura</option>
                <option value="Medicina-Salud">Medicina-Salud</option>
                <option value="Miscel√°nea">Miscel√°nea</option>
                <option value="Mitolog√≠a">Mitolog√≠a</option>
                <option value="M√∫sica">M√∫sica</option>
                <option value="Personajes">Personajes</option>
                <option value="Pol√≠tica">Pol√≠tica</option>
              </select>
            </div>
          </div>
        </div>  
      
    </div>

    <!-- PROCESO 1: Estad√≠sticas de la Jornada -->
    <div class="upload-section">
      <h3>üìä Estad√≠sticas de la Jornada</h3>
      <p>Sube los logs (.txt) de las partidas de una jornada espec√≠fica</p>
      <input type="file" id="fileInputJornada" accept=".txt" multiple />
      <br />
      <button class="button" id="processJornadaBtn" disabled>Procesar Jornada</button>
    </div>

    <!-- PROCESO 2: Totales y Medias -->
    <div class="upload-section" style="border-color: #28a745; background-color: #f8fff9;">
      <h3 id="totalesTitle">üèÜ Totales y Medias Liga</h3>
      <p id="totalesDescription">Sube los Excels (.xlsx) generados de cada jornada para obtener totales acumulados</p>
      <input type="file" id="fileInputTotales" accept=".xlsx" multiple />
      <br />
      <button class="button" id="processTotalesBtn" disabled style="background-color: #28a745;">Generar Totales Liga</button>
    </div>

    <div id="results" class="results" style="display: none;"></div>

    <div id="downloadSection" style="display: none; text-align: center; margin-top: 30px;">
      <button class="button" id="downloadBtn" disabled>üì• Descargar Excel</button>
    </div>
  </div>

<script>
/* ==============================
   ESTADO Y UTILIDADES COMUNES
   ============================== */
let competitionType = 'liga';     // 'liga' | 'gp'
let processedData = [];           // compartido por ambos modos
let fileNames = [];
let currentProcess = '';          // 'jornada' | 'totales'

function showError(msg){ const res=document.getElementById('results'); res.innerHTML=`<div class="error">${msg}</div>`; res.style.display='block'; }
function showSuccess(msg){ const res=document.getElementById('results'); res.innerHTML=`<div class="success">${msg}</div>`; res.style.display='block'; }

const PX_PER_CHAR = 7;
const widthFromPx = (px) => +(px / PX_PER_CHAR).toFixed(2);

/* ===== INIT UI ===== */
document.addEventListener('DOMContentLoaded', () => {
  const selComp = document.getElementById('competitionSelect');
  const inJ = document.getElementById('fileInputJornada');
  const inT = document.getElementById('fileInputTotales');
  const bJ = document.getElementById('processJornadaBtn');
  const bT = document.getElementById('processTotalesBtn');
  const bD = document.getElementById('downloadBtn');

  // Selecci√≥n competici√≥n
  selComp.addEventListener('change', onCompetitionChange);

  // Ficheros
  inJ.addEventListener('change', () => {
    const hasFiles = inJ.files && inJ.files.length;
    
    // Para Copa y M√°ster, solo permitir 1 archivo
    if ((competitionType === 'copa' || competitionType === 'master') && hasFiles && inJ.files.length > 1) {
      showError('Para la Copa y M√°ster solo se puede procesar un archivo');
      bJ.disabled = true;
      return;
    }
    
    bJ.disabled = !hasFiles;
    fileNames = inJ.files? Array.from(inJ.files).map(f=>f.name):[];
    currentProcess='jornada';
  });
  inT.addEventListener('change', () => {
    bT.disabled = !(inT.files && inT.files.length); // Eliminar la restricci√≥n de solo Liga
    fileNames = inT.files? Array.from(inT.files).map(f=>f.name):[];
    currentProcess='totales';
  });

  // Botones
  bJ.addEventListener('click', () => {
    if (competitionType === 'gp') {
      processJornada_GP();
    } else if (competitionType === 'copa') {
      processJornada_COPA();
    } else if (competitionType === 'master') {
      processJornada_MASTER();
    } else if (competitionType === 'relevos') {
      processJornada_RELEVOS();
    } else {
      processJornada_LIGA();
    }
  });
  bT.addEventListener('click', () => (competitionType==='gp' ? processTotales_GP() : processTotales_LIGA()));
  bD.addEventListener('click', () => {
    if (competitionType === 'gp') {
      if (currentProcess === 'totales') {
        downloadExcel_GP_Totales();
      } else {
        downloadExcel_GP();
      }
    } else if (competitionType === 'copa') {
      downloadExcel_COPA();
    } else if (competitionType === 'master') {
      downloadExcel_MASTER();
    } else if (competitionType === 'relevos') {
      downloadExcel_RELEVOS();
    } else {
      downloadExcel_LIGA();
    }
  });

  // Estado inicial
  onCompetitionChange();
});

function onCompetitionChange(){
  competitionType = document.getElementById('competitionSelect').value;
  const gpBox = document.getElementById('gpRoundBox');
  gpBox.style.display = (competitionType==='gp') ? 'inline-block' : 'none';

  // Cambiar textos seg√∫n el tipo de competici√≥n
  const title = document.getElementById('totalesTitle');
  const desc = document.getElementById('totalesDescription');
  const btn = document.getElementById('processTotalesBtn');
  
  if (competitionType === 'gp') {
    title.textContent = 'üèÜ Totales GP';
    desc.textContent = 'Sube los Excels (.xlsx) de GP generados de cada jornada para obtener totales acumulados';
    btn.textContent = 'Generar Totales GP';
  } else if (competitionType === 'copa') {
    title.textContent = 'üèÜ Final de Copa';
    desc.textContent = 'Sube el Excel (.xlsx) de la Copa para generar estad√≠sticas finales';
    btn.textContent = 'Generar Final Copa';
  } else if (competitionType === 'master') {
    title.textContent = 'üèÜ M√°ster por Equipos';
    desc.textContent = 'Sube el log (.txt) del M√°ster por Equipos para generar estad√≠sticas';
    btn.textContent = 'Generar M√°ster';
  } else {
    title.textContent = 'üèÜ Totales y Medias Liga';
    desc.textContent = 'Sube los Excels (.xlsx) generados de cada jornada para obtener totales acumulados';
    btn.textContent = 'Generar Totales Liga';
  }

  // Reset UI de descarga al cambiar modo
  document.getElementById('results').style.display = 'none';
  document.getElementById('downloadSection').style.display = 'none';
  document.getElementById('downloadBtn').disabled = true;

  // Bot√≥n Totales habilitado en Liga y GP, deshabilitado en Copa
  const inT = document.getElementById('fileInputTotales');
  if (competitionType === 'copa' || competitionType === 'master') {
    document.getElementById('processTotalesBtn').disabled = true;
    document.getElementById('processTotalesBtn').style.opacity = '0.5';
  } else {
    document.getElementById('processTotalesBtn').disabled = !(inT.files && inT.files.length);
    document.getElementById('processTotalesBtn').style.opacity = '1';
  }

  // Agregar event listener para el cambio de GP Round
  const gpRoundSelect = document.getElementById('gpRoundSelect');
  if (gpRoundSelect) {
    gpRoundSelect.addEventListener('change', onGPRoundChange);
    onGPRoundChange(); // Llamar una vez para configurar el estado inicial
  }
  
  }

  function onGPRoundChange() {
    const gpRound = document.getElementById('gpRoundSelect')?.value;
    const singleThemeBox = document.getElementById('gpThemeSelect');
    const finalThemesBox = document.getElementById('gpFinalThemesBox');
    
    if (gpRound === 'final') {
      // Mostrar selector m√∫ltiple, ocultar selector √∫nico
      if (singleThemeBox) singleThemeBox.style.display = 'none';
      if (finalThemesBox) finalThemesBox.style.display = 'block';
    } else {
      // Mostrar selector √∫nico, ocultar selector m√∫ltiple
      if (singleThemeBox) singleThemeBox.style.display = 'inline-block';
      if (finalThemesBox) finalThemesBox.style.display = 'none';
    }
  }

/* ================================================================
   ====== INICIO BLOQUE LIGA (V14 OK ESTANCO) ‚Äî NO TOCAR ======
   ================================================================ */

// ===== Colores de equipos =====
const COLORES_EQUIPOS = {
  "FOGUETES": {"bg": "#009F9F", "fg": "#00FF00"},
  "ATIPIK@S": {"bg": "#00FF00", "fg": "#0000FF"},
  "REPESCA@S": {"bg": "#C000C0", "fg": "#00FF00"},
  "DARKSHADOWS": {"bg": "#000000", "fg": "#808080"},
  "TELERINEZ": {"bg": "#000000", "fg": "#00FFFF"},
  "KAMIKAZES": {"bg": "#000000", "fg": "#FF0000"},
  "HARDBE@TS": {"bg": "#000000", "fg": "#FFFF00"},
  "LIDERES": {"bg": "#C000C0", "fg": "#FFFFFF"}
};

function xlsToString(v){ if (v == null) return ''; if (typeof v === 'string') return v; if (typeof v === 'number') return String(v); if (v.richText) return v.richText.map(t=>t.text).join(''); if (v.text) return v.text; if (v.result != null) return xlsToString(v.result); return String(v); }
function norm(v){ return xlsToString(v).trim().toUpperCase(); }
function numOrNull(v){ const s = xlsToString(v).replace(',','.').trim(); if(!s) return null; const n=Number(s); return Number.isFinite(n)?n:null; }

function createWorksheetNoGrid(workbook, name){
  const ws = workbook.addWorksheet(name);
  ws.views = [{ state: 'normal', showGridLines: false }];
  return ws;
}

// === Lector de bloques desde "Estad√≠sticas" ===
function findHeaderStartCol(row){
  const n = row.actualCellCount || row.cellCount || 100;
  for (let c=1; c<=n; c++){
    const cVal = norm(row.getCell(c).value);
    const next = norm(row.getCell(c+1).value);
    const isP = (cVal==='PUNTOS' || cVal==='PUNT.');
    const isS = (next==='SCRATCHES' || next==='SCR');
    if (isP && isS) return c;
  }
  return -1;
}
function extractDataFromExcel(worksheet){
  const matches = []; let currentRow = 1; const maxR = worksheet.rowCount || 10000;
  while (currentRow <= maxR){
    const row = worksheet.getRow(currentRow);
    const startCol = findHeaderStartCol(row);
    if (startCol !== -1){
      const m = extractSingleMatch(worksheet, currentRow, startCol);
      if (m) matches.push(m);
      currentRow = currentRow + 1;
    } else { currentRow++; }
  }
  return matches;
}
function extractSingleMatch(worksheet, startRow, startCol){
  try{
    const teamRow = worksheet.getRow(startRow + 1);
    const teams = {}; const teamOrder = []; const players = [];
    let col = Math.max(1, startCol - 1);
    const maxC = worksheet.columnCount || 60;
    while (col <= maxC){
      const teamName = xlsToString(teamRow.getCell(col).value).trim();
      if (!teamName) break;
      const teamPoints = numOrNull(teamRow.getCell(col + 1).value);
      teams[teamName] = teamPoints ?? 0; teamOrder.push(teamName);
      for (let r = startRow + 2; r < startRow + 12; r++){
        const row = worksheet.getRow(r);
        const name = xlsToString(row.getCell(col).value).trim();
        if (!name) continue;
        const pPoints = numOrNull(row.getCell(col + 1).value);
        const pScr    = numOrNull(row.getCell(col + 2).value) ?? 0;
        const pPalos  = numOrNull(row.getCell(col + 3).value) ?? 0;
        const pAces   = numOrNull(row.getCell(col + 4).value) ?? 0;
        const absent = (pPoints === null);
        players.push({ name: name.toUpperCase(), team: teamName, points: absent ? null : pPoints, scratches: absent ? 0 : pScr, palos: absent ? 0 : pPalos, aces: absent ? 0 : pAces, absent });
      }
      col += 6; // 5 datos + separador
    }
    return { teams, teamOrder, players };
  }catch(e){ console.error('extractSingleMatch error', e); return null; }
}

function displayTotalesOnlyResults(){
  const resultsDiv = document.getElementById('results'); resultsDiv.innerHTML='';
  const allPlayers = new Set(); let totalMatches = processedData.length;
  processedData.forEach(m => m.players.forEach(p => allPlayers.add(p.name)));
  const info = document.createElement('div'); info.className='log-info';
  info.innerHTML = `<h3>üèÜ Totales Liga Procesados</h3>
    <p><strong>Jornadas procesadas:</strong> ${fileNames.length}</p>
    <p><strong>Partidas totales:</strong> ${totalMatches}</p>
    <p><strong>Jugadores √∫nicos:</strong> ${allPlayers.size}</p>
    <p><em>Pulsa "Descargar Excel" para generar el acumulado</em></p>`;
  resultsDiv.appendChild(info); resultsDiv.style.display='block';
}
function displayResults(allData){
  const resultsDiv = document.getElementById('results'); resultsDiv.innerHTML = '';
  const info = document.createElement('div'); info.className = 'log-info';
  let totalTeams = 0, totalPlayers = 0;
  allData.forEach(d => { totalTeams += d.teamOrder.length; totalPlayers += d.players.length; });
  info.innerHTML = `<h3>üìä Informaci√≥n de los Logs</h3>
    <p><strong>Partidas procesadas:</strong> ${allData.length}</p>
    <p><strong>Total de equipos:</strong> ${totalTeams}</p>
    <p><strong>Total de jugadores:</strong> ${totalPlayers}</p>`;
  resultsDiv.appendChild(info); resultsDiv.style.display='block';
}

// Agregados
function aggregateTeamsFromProcessed(processed){
  const teamTotals = {};
  function awardSco(a, b){ if (a > b) return [3,1]; if (a < b) return [1,3]; return [2,2]; }
  processed.forEach(match => {
    match.teamOrder.forEach(teamName => {
      if (!teamTotals[teamName]) teamTotals[teamName] = { name:teamName, totalPoints:0,totalPalos:0,totalScratches:0,totalAces:0,totalAsistencia:0,gamesPlayed:0, scoPuntos:0, scoScratches:0 };
    });
    if (match.teamOrder.length >= 2){
      const A = match.teamOrder[0], B = match.teamOrder[1];
      const pA = +(match.teams[A] || 0), pB = +(match.teams[B] || 0);
      const [sA, sB] = awardSco(pA, pB);
      teamTotals[A].scoPuntos += sA; teamTotals[B].scoPuntos += sB;
    }
    const scratchesByTeam = {};
    match.teamOrder.forEach(teamName => {
      teamTotals[teamName].totalPoints += match.teams[teamName] || 0;
      const teamPlayers = match.players.filter(p=>p.team===teamName && !p.absent);
      teamTotals[teamName].totalAsistencia += teamPlayers.length;
      teamTotals[teamName].gamesPlayed += 1;
      let scrSum = 0;
      teamPlayers.forEach(p=>{
        teamTotals[teamName].totalPalos += p.palos||0;
        teamTotals[teamName].totalScratches += p.scratches||0; scrSum += p.scratches||0;
        teamTotals[teamName].totalAces += p.aces||0;
      });
      scratchesByTeam[teamName] = scrSum;
    });
    if (match.teamOrder.length >= 2){
      const A = match.teamOrder[0], B = match.teamOrder[1];
      const sA = scratchesByTeam[A] || 0, sB = scratchesByTeam[B] || 0;
      const [sa, sb] = awardSco(sA, sB);
      teamTotals[A].scoScratches += sa; teamTotals[B].scoScratches += sb;
    }
  });
  return Object.values(teamTotals).map(t=>({ ...t,
    avgPoints: t.gamesPlayed? t.totalPoints/t.gamesPlayed:0,
    avgPalos: t.gamesPlayed? t.totalPalos/t.gamesPlayed:0,
    avgScratches: t.gamesPlayed? t.totalScratches/t.gamesPlayed:0,
    avgAces: t.gamesPlayed? t.totalAces/t.gamesPlayed:0,
    avgAsistencia: t.gamesPlayed? t.totalAsistencia/t.gamesPlayed:0
  }));
}
function aggregatePlayersFromProcessed(processed){
  const playerTotals = {};
  processed.forEach(match=>{
    match.players.forEach(p=>{
      if (!p.absent){
        if (!playerTotals[p.name]) playerTotals[p.name] = { name:p.name, team:p.team, totalPoints:0,totalPalos:0,totalScratches:0,totalAces:0,gamesPlayed:0 };
        const r = playerTotals[p.name];
        r.team=p.team; r.totalPoints += p.points||0; r.totalPalos += p.palos||0; r.totalScratches += p.scratches||0; r.totalAces += p.aces||0; r.gamesPlayed += 1;
      }
    });
  });
  return Object.values(playerTotals).map(p=>({ ...p,
    avgPoints: p.gamesPlayed? p.totalPoints/p.gamesPlayed:0,
    avgPalos: p.gamesPlayed? p.totalPalos/p.gamesPlayed:0,
    avgScratches: p.gamesPlayed? p.totalScratches/p.gamesPlayed:0,
    avgAces: p.gamesPlayed? p.totalAces/p.gamesPlayed:0
  }));
}

// PROCESO 1 LIGA
function processJornada_LIGA(){
  const files = document.getElementById('fileInputJornada').files;
  if (!files || files.length === 0) return showError('Selecciona al menos un archivo de log');
  processedData = []; let processed = 0;
  Array.from(files).forEach((file, index)=>{
    const reader = new FileReader();
    reader.onload = (e)=>{
      try{
        const content = e.target.result;
        const data = parseLogFileSymbols(content);
        processedData[index] = data;
        processed++;
        if (processed === files.length){
          displayResults(processedData);
          document.getElementById('downloadSection').style.display='block';
          document.getElementById('downloadBtn').disabled = false;
          currentProcess='jornada';
          showSuccess(`${files.length} archivo${files.length>1?'s':''} de log procesado${files.length>1?'s':''} correctamente`);
        }
      }catch(err){ showError(`Error al procesar ${file.name}: ${err.message}`); }
    };
    reader.readAsText(file);
  });
}

// PROCESO 2 LIGA
async function processTotales_LIGA(){
  if (competitionType!=='liga') return; // bot√≥n ya se desactiva en GP
  const files = document.getElementById('fileInputTotales').files;
  if (!files || files.length === 0) return showError('Selecciona al menos un archivo Excel (.xlsx)');
  try{
    processedData = []; fileNames = Array.from(files).map(f=>f.name);
    for (const file of files){
      const buffer = await file.arrayBuffer();
      const workbook = new ExcelJS.Workbook();
      await workbook.xlsx.load(buffer);
      const worksheet =
        workbook.getWorksheet('Estad√≠sticas') ||
        workbook.getWorksheet('Estadisticas') ||
        workbook.worksheets.find(ws => (ws.name||'').toLowerCase().includes('estadist'));
      if (!worksheet){ showError(`El archivo ${file.name} no tiene hoja 'Estad√≠sticas'`); return; }
      const matchData = extractDataFromExcel(worksheet);
      processedData.push(...matchData);
    }
    if (processedData.length === 0){
      showError("No se localizaron partidas en 'Estad√≠sticas'.");
      return;
    }
    displayTotalesOnlyResults();
    document.getElementById('downloadSection').style.display='block';
    document.getElementById('downloadBtn').disabled = false;
    currentProcess='totales';
    showSuccess(`${fileNames.length} archivo${fileNames.length>1?'s':''} de jornada procesado${fileNames.length>1?'s':''} correctamente`);
  }catch(err){ showError('Error procesando archivos Excel: '+err.message); }
}

// DESCARGA LIGA (Estad√≠sticas o Totales)
async function downloadExcel_LIGA(){
  if (!processedData || processedData.length === 0) return showError('No hay datos procesados');
  const wb = new ExcelJS.Workbook();

  if (currentProcess === 'jornada'){
    // Hoja Estad√≠sticas
    const ws = createWorksheetNoGrid(wb, 'Estad√≠sticas');
    const NAME_W = widthFromPx(121);
    let currentRow = 1;

    processedData.forEach(matchData => {
      const teams = matchData.teamOrder.map(teamName => ({
        name: teamName,
        points: matchData.teams[teamName],
        players: matchData.players.filter(p=>p.team===teamName).sort((a,b)=>{
          if (a.absent && !b.absent) return 1; if(!a.absent && b.absent) return -1; return (b.points||0)-(a.points||0);
        }),
        colors: COLORES_EQUIPOS[teamName] || { bg:'#CCCCCC', fg:'#000000' }
      }));

      const teamTotals = teams.map(t=>{
        const tt={scratches:0, palos:0, aces:0};
        t.players.forEach(p=>{ if(!p.absent){ tt.scratches+=p.scratches; tt.palos+=p.palos; tt.aces+=p.aces; } });
        return tt;
      });

      const hdr = [''];
      teams.forEach((t,i)=>{ hdr.push(''); hdr.push('Puntos'); hdr.push('Scratches'); hdr.push('Palos'); hdr.push('Aces'); if(i<teams.length-1) hdr.push(''); });
      ws.getRow(currentRow).values = hdr;

      const tot = [''];
      teams.forEach((t,i)=>{ tot.push(t.name); tot.push(t.points); tot.push(teamTotals[i].scratches); tot.push(teamTotals[i].palos); tot.push(teamTotals[i].aces); if(i<teams.length-1) tot.push(''); });
      ws.getRow(currentRow+1).values = tot;

      let col=2; teams.forEach((t,ti)=>{
        for(let i=0;i<5;i++){ const c=ws.getCell(currentRow, col+i); c.font={bold:false,size:13}; c.alignment={horizontal:'center',vertical:'center'}; c.border={top:{style:'thin'},left:{style:'thin'},bottom:{style:'thin'},right:{style:'thin'}}; }
        for(let i=0;i<5;i++){
          const c=ws.getCell(currentRow+1, col+i);
          if(i===0){ c.fill={type:'pattern',pattern:'solid',fgColor:{argb:t.colors.bg.replace('#','FF')}}; c.font={color:{argb:t.colors.fg.replace('#','FF')},bold:true,size:14}; }
          else if (i===1){ c.font={bold:true,size:12}; }
          else { c.font={bold:false,size:12}; }
          c.alignment={horizontal:'center',vertical:'center'};
          c.border={top:{style:'thin'},left:{style:'thin'},bottom:{style:'thin'},right:{style:'thin'}};
        }
        col += (ti<teams.length-1)?6:5;
      });

      const valOrBlank = (v, keepZero=false) => { if (v == null) return ''; if (v === 0) return keepZero ? 0 : ''; return v; };

      let rowsWritten = 0;
      for(let i=0;i<10;i++){
        const hasAny = teams.some(t=>i<t.players.length);
        if(!hasAny) break;
        const r = currentRow+2+rowsWritten;
        rowsWritten++;

        const row=[''];
        teams.forEach((t,ti)=>{
          const p=t.players[i];
          if(p){
            row.push(
              p.name,
              p.absent ? '' : valOrBlank(p.points, true),
              p.absent ? '' : valOrBlank(p.scratches, false),
              p.absent ? '' : valOrBlank(p.palos, false),
              p.absent ? '' : valOrBlank(p.aces, false)
            );
          } else {
            row.push('','','','','');
          }
          if(ti<teams.length-1) row.push('');
        });
        ws.getRow(r).values = row;

        let c=2; teams.forEach((t,ti)=>{
          const p=t.players[i];
          if(p){
            for(let j=0;j<5;j++){
              const cell=ws.getCell(r, c+j);
              cell.border={top:{style:'thin'},left:{style:'thin'},bottom:{style:'thin'},right:{style:'thin'}};
              cell.alignment={horizontal: j===0?'left':'center', vertical:'center'};
            }
          }
          c += (ti<teams.length-1)?6:5;
        });
      }

      currentRow += 2 + rowsWritten + 2; // 2 filas en blanco entre bloques
    });

    if (processedData.length>0){
      const tcount=processedData[0].teamOrder.length;
      const widths=[3];
      for(let i=0;i<tcount;i++){
        widths.push(widthFromPx(121), 8, 10, 8, 8);
        if(i<tcount-1) widths.push(6);
      }
      const wsCols = widths.map(w=>({width:w}));
      ws.columns = wsCols;
      // margen superior e inferior
      ws.spliceRows(1, 0, []); ws.addRow([]);
    }

  } else {
    // Totales Liga (dos hojas)
    const ws = createWorksheetNoGrid(wb, 'Totales');
    generateTotalsSheet(ws);
    const ws2 = createWorksheetNoGrid(wb, 'Totales2');
    generateTotalsTeamsSheet(ws2, 14); // <- aqu√≠ ajustamos AVG de PUNTOS/POSTES/SCRATCHES a 59 px
  }

  const buffer = await wb.xlsx.writeBuffer();
  const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url;
  if (currentProcess==='jornada'){
    const base = fileNames.map(n=>n.replace(/\.txt$/,'')).join('_');
    a.download = `Jornada_${base}.xlsx`;
  } else {
    a.download = `Totales_Liga_${new Date().toISOString().slice(0,10)}.xlsx`;
  }
  a.click(); URL.revokeObjectURL(url);
  showSuccess(`Excel generado correctamente ‚Äì ${currentProcess==='jornada'?'Estad√≠sticas de Jornada':'Totales Liga'}`);
}

// Totales (jugadores + equipos)
function generateTotalsSheet(ws){
  const players = aggregatePlayersFromProcessed(processedData);
  const teamsArr = aggregateTeamsFromProcessed(processedData);
  function getTeamColors(teamName){ return COLORES_EQUIPOS[teamName] || { bg:'#000000', fg:'#FFFFFF' }; }

  const byTotAvg = (getTot, getAvg) => (a,b)=>{
    const t = getTot(b) - getTot(a);
    if (t !== 0) return t;
    const v = getAvg(b) - getAvg(a);
    if (v !== 0) return v;
    return String(a.name).localeCompare(String(b.name),'es',{sensitivity:'base'});
  };
  const byScoTotAvg = (getSco, getTot, getAvg) => (a,b)=>{
    const s = getSco(b) - getSco(a);
    if (s !== 0) return s;
    const t = getTot(b) - getTot(a);
    if (t !== 0) return t;
    const v = getAvg(b) - getAvg(a);
    if (v !== 0) return v;
    return String(a.name).localeCompare(String(b.name),'es',{sensitivity:'base'});
  };

  // Jugadores
  const pBlocks = [
    { title:'PUNTOS',     baseCol:2,  sort: byTotAvg(p=>p.totalPoints,    p=>p.avgPoints),    pick:(p)=>[p.totalPoints,p.gamesPlayed,+p.avgPoints.toFixed(1)] },
    { title:'POSTES',     baseCol:7,  sort: byTotAvg(p=>p.totalPalos,     p=>p.avgPalos),     pick:(p)=>[p.totalPalos,p.gamesPlayed,+p.avgPalos.toFixed(1)] },
    { title:'SCRATCHES',  baseCol:12, sort: byTotAvg(p=>p.totalScratches, p=>p.avgScratches), pick:(p)=>[p.totalScratches,p.gamesPlayed,+p.avgScratches.toFixed(1)] },
    { title:'ACES',       baseCol:17, sort: byTotAvg(p=>p.totalAces,      p=>p.avgAces),      pick:(p)=>[p.totalAces,p.gamesPlayed,+p.avgAces.toFixed(1)] }
  ];

  pBlocks.forEach(b => {
    const titleCell = ws.getCell(1, b.baseCol+2);
    titleCell.value = b.title;
    if (b.title === 'SCRATCHES') titleCell.alignment = { horizontal: 'center' };

    ws.getCell(2, b.baseCol).value   = 'NOMBRE';
    ws.getCell(2, b.baseCol+1).value = 'TOT';
    ws.getCell(2, b.baseCol+2).value = 'JUG';
    ws.getCell(2, b.baseCol+3).value = 'AVG';
    ws.getCell(2, b.baseCol+1).alignment = { horizontal: 'right' };
    ws.getCell(2, b.baseCol+2).alignment = { horizontal: 'right' };
    ws.getCell(2, b.baseCol+3).alignment = { horizontal: 'right' };
  });

  // Jugadores (datos) + numeraci√≥n izquierda #1..#33
  pBlocks.forEach(b => {
    const data = [...players].sort(b.sort);
    data.forEach((p, idx)=>{
      const row = 3 + idx; const colors = getTeamColors(p.team);
      const nameCell = ws.getCell(row, b.baseCol);
      nameCell.value = p.name; nameCell.font = { color:{ argb: colors.fg.replace('#','FF') } };
      nameCell.fill = { type:'pattern', pattern:'solid', fgColor:{ argb: colors.bg.replace('#','FF') } };
      const [tot,gp,avg] = b.pick(p);
      ws.getCell(row, b.baseCol+1).value = tot; ws.getCell(row, b.baseCol+1).alignment = { horizontal:'right' };
      ws.getCell(row, b.baseCol+2).value = gp;  ws.getCell(row, b.baseCol+2).alignment = { horizontal:'right' };
      ws.getCell(row, b.baseCol+3).value = avg; ws.getCell(row, b.baseCol+3).alignment = { horizontal:'right' };

      if (b.title === 'PUNTOS'){
        const rank = idx + 1;
        const c = ws.getCell(row, 1);
        c.value = (rank <= 33) ? `#${rank}` : '';
        c.alignment = { horizontal:'center' };
        c.font = (rank <= 10) ? { bold:true, size:10 } : { size:10 };
      }
    });
  });

  // Doble fila vac√≠a despu√©s del #33
  if (players.length > 33){
    const cutRow = 36;
    ws.spliceRows(cutRow, 0, [], []);
    try { ws.getRow(cutRow).height = 7.5; ws.getRow(cutRow + 1).height = 7.5; } catch {}
  }

  // Equipos
  const tBlocks = [
    { title:'PUNTOS',     baseCol:24, hasSco:true,  sort: byScoTotAvg(t=>t.scoPuntos, t=>t.totalPoints, t=>t.avgPoints),       pick:(t)=>({ sco:t.scoPuntos||0,    tot:t.totalPoints,    jug:t.gamesPlayed, avg:+t.avgPoints.toFixed(1) }) },
    { title:'POSTES',     baseCol:30, hasSco:false, sort: byTotAvg(t=>t.totalPalos, t=>t.avgPalos),                             pick:(t)=>({ tot:t.totalPalos,      jug:t.gamesPlayed,    avg:+t.avgPalos.toFixed(1) }) },
    { title:'SCRATCHES',  baseCol:35, hasSco:true,  sort: byScoTotAvg(t=>t.scoScratches, t=>t.totalScratches, t=>t.avgScratches), pick:(t)=>({ sco:t.scoScratches||0, tot:t.totalScratches, jug:t.gamesPlayed, avg:+t.avgScratches.toFixed(1) }) },
    { title:'ACES',       baseCol:41, hasSco:false, sort: byTotAvg(t=>t.totalAces, t=>t.avgAces),                               pick:(t)=>({ tot:t.totalAces,       jug:t.gamesPlayed,    avg:+t.avgAces.toFixed(1) }) },
    { title:'ASISTENCIA', baseCol:46, hasSco:false, sort: byTotAvg(t=>t.totalAsistencia, t=>t.avgAsistencia),                   pick:(t)=>({ tot:t.totalAsistencia, jug:t.gamesPlayed,    avg:+t.avgAsistencia.toFixed(1) }) }
  ];

  tBlocks.forEach(b => {
    const ttl = ws.getCell(1, b.baseCol+2); ttl.value = b.title;
    if (b.title === 'ASISTENCIA') ttl.alignment = { horizontal: 'center' };
    ws.getCell(2, b.baseCol).value = 'EQUIPO';
    if (b.hasSco){
      ws.getCell(2, b.baseCol+1).value = 'SCO';
      ws.getCell(2, b.baseCol+2).value = 'TOT';
      ws.getCell(2, b.baseCol+3).value = 'JUG';
      ws.getCell(2, b.baseCol+4).value = 'AVG';
      ws.getCell(2, b.baseCol+1).alignment = { horizontal:'center' };
      [2,3,4].forEach(off=> ws.getCell(2, b.baseCol+off).alignment = { horizontal:'right' });
    } else {
      ws.getCell(2, b.baseCol+1).value = 'TOT';
      ws.getCell(2, b.baseCol+2).value = 'JUG';
      ws.getCell(2, b.baseCol+3).value = 'AVG';
      [1,2,3].forEach(off=> ws.getCell(2, b.baseCol+off).alignment = { horizontal:'right' });
    }
  });

  // Datos equipos
  tBlocks.forEach(b => {
    const data = [...teamsArr].sort(b.sort);
    data.forEach((t, idx)=>{
      const row = 3 + idx; const colors = COLORES_EQUIPOS[t.name] || { bg:'#000000', fg:'#FFFFFF' };
      const nameCell = ws.getCell(row, b.baseCol);
      nameCell.value = t.name;
      nameCell.font = { color:{ argb: colors.fg.replace('#','FF') } };
      nameCell.fill = { type:'pattern', pattern:'solid', fgColor:{ argb: colors.bg.replace('#','FF') } };

      let colOff = 1;
      if (b.hasSco){ const c=ws.getCell(row, b.baseCol+colOff); c.value=t.scoPuntos||0; c.alignment={horizontal:'center'}; colOff++; }
      const cTot = ws.getCell(row, b.baseCol+colOff); cTot.value = (
        b.title==='PUNTOS' ? t.totalPoints :
        b.title==='POSTES' ? t.totalPalos :
        b.title==='SCRATCHES' ? t.totalScratches :
        b.title==='ACES' ? t.totalAces : t.totalAsistencia
      ) || 0; cTot.alignment={horizontal:'right'}; colOff++;
      const cJug = ws.getCell(row, b.baseCol+colOff); cJug.value = t.gamesPlayed || 0; cJug.alignment={horizontal:'right'}; colOff++;
      const avgVal =
        b.title==='PUNTOS'     ? t.avgPoints :
        b.title==='POSTES'     ? t.avgPalos :
        b.title==='SCRATCHES'  ? t.avgScratches :
        b.title==='ACES'       ? t.avgAces : t.avgAsistencia;
      const cAvg = ws.getCell(row, b.baseCol+colOff); cAvg.value = +Number(avgVal||0).toFixed(1); cAvg.alignment={horizontal:'right'};
    });
  });

  // Anchos Totales (con margen izq/der)
  const NAME_W = widthFromPx(121);
  const MARGIN_PX = 27, NUM_PX = 35;
  const marginW = widthFromPx(MARGIN_PX), numW = widthFromPx(NUM_PX);
  ws.columns = [
    { width: marginW },
    { width: NAME_W }, { width: numW }, { width: numW }, { width: numW }, { width: 3 },
    { width: NAME_W }, { width: numW }, { width: numW }, { width: numW }, { width: 3 },
    { width: NAME_W }, { width: numW }, { width: numW }, { width: numW }, { width: 3 },
    { width: NAME_W }, { width: numW }, { width: numW }, { width: numW }, { width: 3 },
    { width: 3 }, { width: 3 },
    { width: 15 }, { width: numW }, { width: numW }, { width: numW }, { width: numW }, { width: 3 },
    { width: 15 }, { width: numW }, { width: numW }, { width: numW }, { width: 3 },
    { width: 15 }, { width: numW }, { width: numW }, { width: numW }, { width: numW }, { width: 3 },
    { width: 15 }, { width: numW }, { width: numW }, { width: numW }, { width: 3 },
    { width: 15 }, { width: numW }, { width: numW }, { width: numW }
  ];
  // Margen arriba/abajo
  ws.spliceRows(1, 0, []); ws.addRow([]);
}

// Totales2 (equipos por bloques) ‚Äî incluye ajuste AVG 59 px
function generateTotalsTeamsSheet(ws, fontSize = 14){
  const teams = aggregateTeamsFromProcessed(processedData);
  function getTeamColors(teamName){ return COLORES_EQUIPOS[teamName] || { bg:'#000000', fg:'#FFFFFF' }; }

  const byTotAvg = (getTot, getAvg) => (a,b)=>{
    const t = getTot(b) - getTot(a);
    if (t !== 0) return t;
    const v = getAvg(b) - getAvg(a);
    if (v !== 0) return v;
    return String(a.name).localeCompare(String(b.name),'es',{sensitivity:'base'});
  };
  const byScoTotAvg = (getSco, getTot, getAvg) => (a,b)=>{
    const s = getSco(b) - getSco(a);
    if (s !== 0) return s;
    const t = getTot(b) - getTot(a);
    if (t !== 0) return t;
    const v = getAvg(b) - getAvg(a);
    if (v !== 0) return v;
    return String(a.name).localeCompare(String(b.name),'es',{sensitivity:'base'});
  };

  const tBlocks = [
    { title:'PUNTOS',     baseCol:2,  hasSco:true,  sort: byScoTotAvg(t=>t.scoPuntos, t=>t.totalPoints, t=>t.avgPoints), pick:(t)=>({ sco:t.scoPuntos||0,    tot:t.totalPoints,    jug:t.gamesPlayed,    avg:+t.avgPoints.toFixed(1) }) },
    { title:'POSTES',     baseCol:8,  hasSco:false, sort: byTotAvg(t=>t.totalPalos, t=>t.avgPalos),                       pick:(t)=>({ tot:t.totalPalos,      jug:t.gamesPlayed,    avg:+t.avgPalos.toFixed(1) }) },
    { title:'SCRATCHES',  baseCol:13, hasSco:true,  sort: byScoTotAvg(t=>t.scoScratches, t=>t.totalScratches, t=>t.avgScratches), pick:(t)=>({ sco:t.scoScratches||0, tot:t.totalScratches, jug:t.gamesPlayed, avg:+t.avgScratches.toFixed(1) }) },
    { title:'ACES',       baseCol:19, hasSco:false, sort: byTotAvg(t=>t.totalAces, t=>t.avgAces),                           pick:(t)=>({ tot:t.totalAces,       jug:t.gamesPlayed,    avg:+t.avgAces.toFixed(1) }) },
    { title:'ASISTENCIA', baseCol:24, hasSco:false, sort: byTotAvg(t=>t.totalAsistencia, t=>t.avgAsistencia),             pick:(t)=>({ tot:t.totalAsistencia, jug:t.gamesPlayed,    avg:+t.avgAsistencia.toFixed(1) }) }
  ];

  tBlocks.forEach(b => {
    const ttl = ws.getCell(1, b.baseCol+2); ttl.value = b.title; ttl.font = { bold:true, size: fontSize };
    if (b.title === 'ASISTENCIA') ttl.alignment = { horizontal: 'center' };
    ws.getCell(2, b.baseCol).value = 'EQUIPO'; ws.getCell(2, b.baseCol).font = { bold:true, size: fontSize };
    if (b.hasSco){
      ['SCO','TOT','JUG','AVG'].forEach((t,i)=>{ const c = ws.getCell(2, b.baseCol+1+i); c.value = t; c.font = { bold:true, size: fontSize }; c.alignment = (i===0) ? { horizontal:'center' } : { horizontal:'right' }; });
    } else {
      ['TOT','JUG','AVG'].forEach((t,i)=>{ const c = ws.getCell(2, b.baseCol+1+i); c.value = t; c.alignment = { horizontal:'right' }; c.font = { bold:true, size: fontSize }; });
    }
  });

  tBlocks.forEach(b => {
    const data = [...teams].sort(b.sort);
    data.forEach((t, idx)=>{
      const row = 3 + idx; const colors = getTeamColors(t.name);
      const nameCell = ws.getCell(row, b.baseCol);
      nameCell.value = t.name;
      nameCell.font = { color:{ argb: colors.fg.replace('#','FF') }, size: fontSize };
      nameCell.fill = { type:'pattern', pattern:'solid', fgColor:{ argb: colors.bg.replace('#','FF') } };

      const vals = b.pick(t);
      let colOff = 1;
      if (b.hasSco){ const c=ws.getCell(row, b.baseCol+colOff); c.value=vals.sco; c.alignment={horizontal:'center'}; c.font={size:fontSize}; colOff++; }
      const cTot = ws.getCell(row, b.baseCol+colOff); cTot.value = vals.tot; cTot.alignment={horizontal:'right'}; cTot.font={size:fontSize}; colOff++;
      const cJug = ws.getCell(row, b.baseCol+colOff); cJug.value = vals.jug; cJug.alignment={horizontal:'right'}; cJug.font={size:fontSize}; colOff++;
      const cAvg = ws.getCell(row, b.baseCol+colOff); cAvg.value = vals.avg; cAvg.alignment={horizontal:'right'}; cAvg.font={size:fontSize};
    });
  });

  // Anchos Totales2: num√©ricos 44px; AVG de PUNTOS/POSTES/SCRATCHES a 59px
  const NUM2_PX = 44, num2W = widthFromPx(NUM2_PX);
  const AVG_W = widthFromPx(59);
  ws.columns = [
    { width: 2.25 },                                                      // 1 margen izq
    { width: 18 }, { width: num2W }, { width: num2W }, { width: num2W }, { width: AVG_W }, { width: 3 }, // PUNTOS (AVG ancho 59px)
    { width: 18 }, { width: num2W }, { width: num2W }, { width: AVG_W }, { width: 3 },                   // POSTES (AVG ancho 59px)
    { width: 18 }, { width: num2W }, { width: num2W }, { width: num2W }, { width: AVG_W }, { width: 3 }, // SCRATCHES (AVG ancho 59px)
    { width: 18 }, { width: num2W }, { width: num2W }, { width: num2W }, { width: 3 },                   // ACES
    { width: 18 }, { width: num2W }, { width: num2W }, { width: num2W },                                 // ASISTENCIA
    { width: 2.25 }                                                                                       //  √∫ltimo margen dcho
  ];
  // M√°rgenes arriba/abajo
  ws.spliceRows(1, 0, []); ws.addRow([]);
}

// Parser LIGA desde TXT
function parseLogFileSymbols(content){
  const lines = content.split('\n').map(l=>l.trim()).filter(Boolean);
  const teamStart = lines.findIndex(l=>l.toUpperCase().includes('CLASIFICACION EQUIPOS'));
  const playerStart = lines.findIndex(l=>l.toUpperCase().includes('CLASIFICACION INDIVIDUAL'));
  if (teamStart === -1 || playerStart === -1) throw new Error('Secciones no encontradas');

  const teams = {}, teamOrder = [];
  for (let i=teamStart+1; i<playerStart; i++){
    const m = /^(.*?)\s+(-?\d+)\s*$/.exec(lines[i]);
    if (!m) continue;
    const team = m[1].trim();
    const points = parseInt(m[2], 10);
    teams[team] = points;
    teamOrder.push(team);
  }

  const players = [];
  for (let i=playerStart+1; i<lines.length; i++){
    const line = lines[i]; if(!line) continue;
    const parts = line.split(/\s+/); if (parts.length < 2) continue;
    const name = parts[0];
    const points = parseInt(parts[1], 10);
    players.push({
      name: name.toUpperCase(),
      points: line.toUpperCase().includes('NO ESTUVO PRESENTE') ? null : points,
      aces: parseInt((line.match(/Aces:\s*(\d+)/i) || [0,0])[1],10),
      scratches: parseInt((line.match(/Scr:\s*(\d+)/i) || [0,0])[1],10),
      palos: parseInt((line.match(/Palos:\s*(\d+)/i) || [0,0])[1],10),
      absent: line.toUpperCase().includes('NO ESTUVO PRESENTE')
    });
  }

  const teamsAlpha = Object.keys(teams).sort((a,b)=>a.localeCompare(b,'es',{sensitivity:'base'}));
  let switched = false;
  if (players.length){
    players[0].team = teamsAlpha[0] || 'SinEquipo';
    let prevNick = players[0].name;
    for (let i=1; i<players.length; i++){
      const curr = players[i];
      if (!switched && curr.name.localeCompare(prevNick,'es',{sensitivity:'base'}) < 0) switched = true;
      curr.team = switched ? (teamsAlpha[1] || 'SinEquipo') : (teamsAlpha[0] || 'SinEquipo');
      prevNick = curr.name;
    }
  }
  return { teams, teamOrder, players };
}

/* ====== FIN BLOQUE LIGA (V14 OK ESTANCO) ====== */


/* ================================================================
   ======================== BLOQUE GP =============================
   ================================================================ */

// Tabla fija de puntos por posici√≥n (1..15). 16+ ‚Üí 0
const GP_TABLE = [20,17,15,13,11,10,9,8,7,6,5,4,3,2,1];

// Detecta el nombre del grupo; si no aparece, devuelve "GRUPO ?"
function detectGroupName(lines, filename=''){
  for (const l of lines){
    const m = l.match(/\bGRUPO\s+([A-Z√ë√Å√â√ç√ì√ö])\b/i);
    if (m) return `GRUPO ${m[1].toUpperCase()}`;
  }
  if (filename){
    const m = filename.match(/GRUPO[_\s-]?([A-Z√ë])/i);
    if (m) return `GRUPO ${m[1].toUpperCase()}`;
  }
  return 'GRUPO ?';
}

function parseGPLog(text, filename=''){
  const lines = String(text).split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const groupName = detectGroupName(lines, filename);

  const players = [];
  for (const L of lines){
    if (/^CLASIFICACION\s+EQUIPOS/i.test(L)) continue;
    if (/^CLASIFICACION\s+INDIVIDUAL/i.test(L)) continue;
    if (/^GRUPO\s+/i.test(L)) continue;

    // AUSENTE sin n√∫meros: "NICK    NO ESTUVO PRESENTE"
    const absentMatch = L.match(/^(\S+).*?\bNO\s+ESTUVO\s+PRESENTE$/i);
    if (absentMatch){
      const name = absentMatch[1].trim(); if (!name) continue;
      players.push({ name: name.toUpperCase(), pts:0, pal:0, scr:0, ace:0, present:false, pos:0, gpp:0 });
      continue;
    }

    // PRESENTE: "NICK  PTS  Aces:X  Scr:Y  Palos:Z"
    const m = L.match(/^(.+?)\s+(-?\d+)\s+(?:Aces:\s*(-?\d+))?\s+Scr:\s*(-?\d+)\s+Palos:\s*(-?\d+)/i);
    if (m){
      const name = (m[1]||'').trim(); if (!name) continue;
      players.push({
        name: name.toUpperCase(),
        pts:  parseInt(m[2]||'0',10),
        ace:  parseInt(m[3]||'0',10),
        scr:  parseInt(m[4]||'0',10),
        pal:  parseInt(m[5]||'0',10), // POSTES
        present: true, pos:0, gpp:0
      });
    }
  }

  // Ranking SOLO con presentes (PTS desc, SCR desc, ACE desc)
  const present = players.filter(p=>p.present).sort((a,b)=> (b.pts - a.pts) || (b.scr - a.scr) || (b.ace - a.ace));

  // Posiciones con empates (SOLO por puntos)
for (let i=0, pos=1; i<present.length; ){
  let j=i+1;
  while (j<present.length && present[j].pts===present[i].pts) j++;
  for (let k=i;k<j;k++) present[k].pos = pos;
  pos += (j-i); i = j;
}
  // GPP por media de posiciones empatadas
  for (let i=0; i<present.length; ){
    const startPos = present[i].pos;
    let j=i+1; while (j<present.length && present[j].pos===startPos) j++;
    const endPos = startPos + (j-i) - 1;
    const vals = [];
    for (let r=startPos; r<=endPos; r++){ const idx = r-1; vals.push(idx<GP_TABLE.length ? GP_TABLE[idx] : 0); }
    const avg = vals.reduce((a,b)=>a+b,0)/vals.length;
    for (let k=i;k<j;k++) present[k].gpp = +avg.toFixed(2);
    i = j;
  }

  const map = Object.fromEntries(present.map(p=>[p.name,p]));
  players.forEach(p=>{ if (p.present){ const q = map[p.name]; p.pos = q.pos; p.gpp = q.gpp; } else { p.gpp = 0; p.pos = 0; } });

  // Orden final: presentes arriba por PTS/SCR/ACE; ausentes abajo
  players.sort((a,b)=> (b.present - a.present) || (b.pts - a.pts) || (b.scr - a.scr) || (b.ace - a.ace));

  return { group: groupName, players };
}

function processJornada_GP(){
  const files = document.getElementById('fileInputJornada').files;
  if (!files || files.length === 0) return showError('Selecciona al menos un archivo de log (GP)');
  
  const gpRound = document.getElementById('gpRoundSelect')?.value;
  
  if (gpRound === 'final') {
    // Procesar FINAL - requiere exactamente 5 archivos
    if (files.length !== 5) {
      return showError('Para la FINAL debes subir exactamente 5 archivos (.txt) en el orden de las tem√°ticas seleccionadas');
    }
    
    // Validar que se hayan seleccionado las 5 tem√°ticas
    const themes = [];
    for (let i = 1; i <= 5; i++) {
      const theme = document.getElementById(`gpFinalTheme${i}`)?.value;
      if (!theme) {
        return showError(`Por favor, selecciona la ${i}¬™ tem√°tica antes de procesar la FINAL`);
      }
      themes.push(theme);
    }
    
    // Verificar que no haya tem√°ticas repetidas
    const uniqueThemes = new Set(themes);
    if (uniqueThemes.size !== themes.length) {
      return showError('No puedes repetir tem√°ticas. Cada una debe ser diferente.');
    }
    
    processJornada_GP_Final(files, themes);
  } else {
    // Procesar GP normal - validar tem√°tica √∫nica
    const selectedTheme = document.getElementById('gpThemeSelect')?.value;
    if (!selectedTheme) {
      return showError('Por favor, selecciona una tem√°tica antes de procesar el GP');
    }
    
    processJornada_GP_Normal(files, selectedTheme);
  }
}

function processJornada_GP_Normal(files, theme) {
  processedData = []; let processed = 0;
  Array.from(files).forEach(async (file, index)=>{
    try{
      const text = await file.text();
      const group = parseGPLog(text, file.name);
      processedData[index] = group;
      processed++;
      if (processed === files.length){
        processedData = processedData.filter(Boolean).sort((a,b)=> String(a.group||'').localeCompare(String(b.group||''),'es',{sensitivity:'base'}));
        const res = document.getElementById('results');
        res.innerHTML = `<div class="success">GP: ${files.length} archivo(s) analizado(s). Pulsa "Descargar Excel".</div>`;
        res.style.display = 'block';
        document.getElementById('downloadSection').style.display='block';
        document.getElementById('downloadBtn').disabled = false;
        currentProcess='jornada';
      }
    }catch(err){ showError(`Error GP en ${file.name}: ${err.message}`); }
  });
}

function processJornada_GP_Final(files, themes) {
  processedData = { isFinal: true, themes: themes, logs: [] };
  let processed = 0;
  
  Array.from(files).forEach(async (file, index) => {
    try {
      const text = await file.text();
      const logData = parseGPFinalLog(text, themes[index], index + 1);
      processedData.logs[index] = logData;
      processed++;
      
      if (processed === files.length) {
        // Procesar datos de la final
        const finalResults = processFinalResults(processedData.logs, themes);
        processedData.finalResults = finalResults;
        
        const res = document.getElementById('results');
        res.innerHTML = `<div class="success">FINAL GP: 5 archivos procesados. Pulsa "Descargar Excel".</div>`;
        res.style.display = 'block';
        document.getElementById('downloadSection').style.display='block';
        document.getElementById('downloadBtn').disabled = false;
        currentProcess='jornada';
      }
    } catch(err) { 
      showError(`Error procesando ${file.name}: ${err.message}`); 
    }
  });
}

function parseGPFinalLog(content, theme, gpNumber) {
  const lines = content.split('\n').map(l => l.trim()).filter(Boolean);
  const teamStart = lines.findIndex(l => l.toUpperCase().includes('CLASIFICACION EQUIPOS'));
  const playerStart = lines.findIndex(l => l.toUpperCase().includes('CLASIFICACION INDIVIDUAL'));
  
  if (teamStart === -1 || playerStart === -1) {
    throw new Error('Secciones no encontradas en el log');
  }
  
  const players = {};
  
  // Extraer jugadores
  for (let i = playerStart + 1; i < lines.length; i++) {
    const line = lines[i];
    if (!line) continue;
    
    const parts = line.split(/\s+/);
    if (parts.length < 2) continue;
    
    const name = parts[0].toUpperCase();
    const isAbsent = line.toUpperCase().includes('NO ESTUVO PRESENTE');
    const points = isAbsent ? 0 : parseInt(parts[1], 10);
    const aces = isAbsent ? 0 : parseInt((line.match(/Aces:\s*(\d+)/i) || [0,0])[1], 10);
    const scratches = isAbsent ? 0 : parseInt((line.match(/Scr:\s*(\d+)/i) || [0,0])[1], 10);
    const palos = isAbsent ? 0 : parseInt((line.match(/Palos:\s*(\d+)/i) || [0,0])[1], 10);
    
    players[name] = {
      name: name,
      points: points,
      aces: aces,
      scratches: scratches,
      palos: palos,
      absent: isAbsent
    };
  }
  
  return {
    theme: theme,
    gpNumber: gpNumber,
    players: players
  };
}

function processFinalResults(logs, themes) {
  const allPlayers = {};
  
  // Recopilar todos los jugadores √∫nicos
  logs.forEach(log => {
    Object.keys(log.players).forEach(playerName => {
      if (!allPlayers[playerName]) {
        allPlayers[playerName] = {
          name: playerName,
          totalPoints: 0,
          totalPalos: 0,
          totalScratches: 0,
          totalAces: 0,
          gpResults: {},
          minPoints: Infinity // Para DES (desempate)
        };
      }
    });
  });
  
  // Acumular estad√≠sticas por jugador
  logs.forEach(log => {
    Object.entries(log.players).forEach(([playerName, playerData]) => {
      const player = allPlayers[playerName];
      
      player.totalPoints += playerData.points;
      player.totalPalos += playerData.palos;
      player.totalScratches += playerData.scratches;
      player.totalAces += playerData.aces;
      
      // Calcular DES (m√≠nimo de puntos en cualquier GP)
      if (playerData.points < player.minPoints) {
        player.minPoints = playerData.points;
      }
      
      // Guardar resultados por GP
      player.gpResults[`gp${log.gpNumber}`] = {
        points: playerData.points,
        palos: playerData.palos,
        scratches: playerData.scratches,
        aces: playerData.aces,
        theme: log.theme
      };
    });
  });
  
  // Ordenar jugadores por total de puntos (descendente) y luego por DES (ascendente)
  const sortedPlayers = Object.values(allPlayers).sort((a, b) => {
    if (b.totalPoints !== a.totalPoints) {
      return b.totalPoints - a.totalPoints;
    }
    // En caso de empate, el que tenga menor DES queda arriba
    return a.minPoints - b.minPoints;
  });
  
  return {
    players: sortedPlayers,
    themes: themes
  };
}
  
function buildGPSheet(ws, groups){
  const leftMarginCols = 1, betweenGroupsCols = 4, rightMarginCols = 1;
  const marginW = widthFromPx(24);
  const nameW   = widthFromPx(150);
  const numW    = widthFromPx(40);
  const bandARGB = 'FF0B7D7D';
  const whiteARGB = 'FFFFFFFF';

  const gpRound = Math.min(Math.max(parseInt(document.getElementById('gpRoundSelect')?.value || '1',10),1),5);
  const GPP_LABEL = `GP${gpRound}`;

  ws.views = [{ state: 'normal', showGridLines: false }];

  // Fila vac√≠a arriba (margen superior)
  ws.spliceRows(1, 0, []);
  try { ws.getRow(1).height = 7.5; } catch {}

  // Columnas totales
  const totalCols = leftMarginCols + (groups.length * 6) + ((groups.length - 1) * betweenGroupsCols) + rightMarginCols;
  ws.columns = Array.from({length: totalCols}, ()=>({ width: 11 }));

  // M√°rgenes laterales
  ws.getColumn(1).width = marginW;                      // margen izq = 1
  ws.getColumn(totalCols).width = marginW;              // margen dcho = 1

  const headerRow = 2;
  const dataStartRow = headerRow + 1;
  let baseCol = leftMarginCols + 1;

  groups.forEach((g, idx)=>{
    // Cabecera (con ‚ÄúGRUPO X‚Äù en la primera celda)
    const groupTitle = (g.group && g.group.trim()) ? g.group : 'GRUPO ?';
    const headers = [ groupTitle, GPP_LABEL, 'PTS', 'POS', 'SCR', 'ACE' ];
    for (let off=0; off<6; off++){
      const c = ws.getCell(headerRow, baseCol+off);
      c.value = headers[off];
      c.font = { bold:true, color:{argb:whiteARGB} };
      c.fill = { type:'pattern', pattern:'solid', fgColor:{argb:bandARGB} };
      c.alignment = { horizontal: off===0 ? 'left' : 'center', vertical:'middle' };
      c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} }; // bordes SOLO cabecera
    }

    // Anchos
    ws.getColumn(baseCol).width = nameW;
    for (let off=1; off<=5; off++) ws.getColumn(baseCol+off).width = numW;

    // Datos (sin bordes)
    let r = dataStartRow;
    const putStat = (col, val, present, isPTS = false) => {
      const cell = ws.getCell(r, col);
      if (!present) { 
        cell.value = null; 
      } else {
        const n = Number(val || 0);
        if (isPTS) {
          cell.value = n;  // PTS: mostrar siempre el valor real, incluyendo 0
        } else {
          cell.value = (n === 0) ? null : n;  // SCR/ACE/POS: ocultar si es 0
        }
      }
      cell.alignment = { horizontal:'center', vertical:'middle' };
    };

    (g.players || []).forEach(p=>{
      // Nick
      const cN = ws.getCell(r, baseCol);
      cN.value = p.name || '';
      cN.alignment = { horizontal:'left', vertical:'middle' };

      // GPX (si ausente ‚Üí 0 visible, en negrita)
      const cG = ws.getCell(r, baseCol+1);
      cG.value = (p.gpp ?? 0);
      cG.alignment = { horizontal:'center', vertical:'middle' };
      cG.font = { bold:true };

      // PTS / POS(=POSTES) / SCR / ACE
      putStat(baseCol+2, p.pts, p.present, true);  // PTS (true = mostrar 0)
      putStat(baseCol+3, p.pal, p.present, false); // POS = POSTES (false = ocultar 0)
      putStat(baseCol+4, p.scr, p.present, false); // SCR (false = ocultar 0)
      putStat(baseCol+5, p.ace, p.present, false); // ACE (false = ocultar 0)

      r++;
    });

    // Separaci√≥n entre grupos
    if (idx < groups.length - 1){
      for (let s=0; s<betweenGroupsCols; s++){
        ws.getColumn(baseCol + 6 + s).width = marginW;
      }
      baseCol += 6 + betweenGroupsCols;
    } else {
      baseCol += 6;
    }
  });

  // A√±adir informaci√≥n de tem√°tica al final
  const selectedTheme = document.getElementById('gpThemeSelect')?.value;
  if (selectedTheme) {
    // Encontrar la fila m√°s baja con datos
    let lastDataRow = 2; // Empezar desde la fila de cabeceras
    groups.forEach(g => {
      const groupLastRow = 3 + (g.players?.length || 0);
      if (groupLastRow > lastDataRow) {
        lastDataRow = groupLastRow;
      }
    });
    
    // A√±adir 1 fila de separaci√≥n
    const themeRow = lastDataRow + 1;
    
    // Celda "Tem√°tica:" en la columna 2
    const labelCell = ws.getCell(themeRow, 2);
    labelCell.value = 'Tem√°tica:';
    labelCell.font = { bold: true };
    labelCell.alignment = { horizontal: 'left', vertical: 'middle' };
    
    // Celda con la tem√°tica seleccionada en la columna 3
    const themeCell = ws.getCell(themeRow, 3);
    themeCell.value = selectedTheme.toUpperCase();
    themeCell.font = { bold: true };
    themeCell.alignment = { horizontal: 'left', vertical: 'middle' };
  }

  // Config impresi√≥n
  try {
    ws.pageSetup = { orientation: 'landscape', fitToPage: true,
      margins: { left:0.3, right:0.3, top:0.4, bottom:0.4, header:0.2, footer:0.2 } };
  } catch {}
}

async function downloadExcel_GP(){
  if (!processedData || processedData.length === 0) return showError('No hay datos procesados.');
  
  if (processedData.isFinal) {
    // Descargar Excel de Final
    const wb = new ExcelJS.Workbook();
    wb.created = new Date();
    
    const ws = wb.addWorksheet('GP Final', { views:[{ state:'normal', showGridLines:false }] });
    buildGPFinalSheet(ws, processedData.finalResults);
    
    const uint8 = await wb.xlsx.writeBuffer();
    saveAs(new Blob([uint8], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}), `GP_Final.xlsx`);
    showSuccess('Excel GP Final generado correctamente.');
  } else {
    // Descargar Excel normal
    const wb = new ExcelJS.Workbook();
    wb.created = new Date();

    const ws = wb.addWorksheet('GP', { views:[{ state:'normal', showGridLines:false }] });
    buildGPSheet(ws, processedData);

    const uint8 = await wb.xlsx.writeBuffer();
    const stamp = new Date().toISOString().slice(0,10);
    const gpRound = Math.min(Math.max(parseInt(document.getElementById('gpRoundSelect')?.value || '1',10),1),5);
    saveAs(new Blob([uint8], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}), `GP${gpRound}.xlsx`);
    showSuccess('Excel GP generado correctamente.');
  }
}

function buildGPFinalSheet(ws, finalResults) {
  const marginW = widthFromPx(24);
  const nameW = widthFromPx(120);
  const numW = widthFromPx(40);
  const themeW = widthFromPx(80);
  
  // Colores
  const headerBgARGB = 'FF0B7D7D';
  const whiteARGB = 'FFFFFFFF';
  const blackARGB = 'FF000000';
  const redARGB = 'FFCC0000';
  const greenARGB = 'FF00B050';
  
  // Colores de podio
  const goldARGB = 'FFFFD700';    // Oro
  const silverARGB = 'FFC0C0C0';  // Plata
  const bronzeARGB = 'FFCD7F32';  // Bronce
  
  // Colores alternados para filas
  const lightGrayARGB = 'FFF5F5F5'; // Gris claro para filas alternas
  
  ws.views = [{ state: 'normal', showGridLines: false }];
  
  // Configurar anchos de columnas
  ws.getColumn(1).width = nameW; // NICK
  ws.getColumn(2).width = numW;  // TOT
  ws.getColumn(3).width = numW;  // DES
  ws.getColumn(4).width = numW;  // PO
  ws.getColumn(5).width = numW;  // SC
  ws.getColumn(6).width = numW;  // AC
  
  // Columnas de tem√°ticas (5 grupos de 4 columnas cada uno: PTS, PO, SC, AC)
  for (let i = 0; i < 5; i++) {
    const baseCol = 7 + (i * 4);
    ws.getColumn(baseCol).width = numW;     // PTS
    ws.getColumn(baseCol + 1).width = numW; // PO
    ws.getColumn(baseCol + 2).width = numW; // SC
    ws.getColumn(baseCol + 3).width = numW; // AC
  }
  
  // Cabeceras principales (fila 1)
  const mainHeaders = ['NICK', 'TOT', 'DES', 'PO', 'SC', 'AC'];
  finalResults.themes.forEach(theme => {
    mainHeaders.push(theme.toUpperCase(), '', '', '');
  });
  
  for (let col = 0; col < mainHeaders.length; col++) {
    if (mainHeaders[col]) {
      const cell = ws.getCell(1, col + 1);
      cell.value = mainHeaders[col];
      cell.font = { bold: true, color: { argb: whiteARGB } };
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: headerBgARGB } };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.border = { top: {style: 'thick'}, left: {style: 'thick'}, bottom: {style: 'thin'}, right: {style: 'thin'} };
      
      // Merge para las tem√°ticas (4 columnas cada una)
      if (col >= 6 && (col - 6) % 4 === 0) {
        ws.mergeCells(1, col + 1, 1, col + 4);
      }
    }
  }
  
  // Borde derecho de la √∫ltima columna de cabecera
  const lastHeaderCell = ws.getCell(1, mainHeaders.length);
  lastHeaderCell.border = { ...lastHeaderCell.border, right: {style: 'thick'} };
  
  // Subheaders (fila 2)
  const subHeaders = ['', '', '', '', '', '', 'PTS', 'PO', 'SC', 'AC', 'PTS', 'PO', 'SC', 'AC', 'PTS', 'PO', 'SC', 'AC', 'PTS', 'PO', 'SC', 'AC', 'PTS', 'PO', 'SC', 'AC'];
  
  for (let col = 0; col < subHeaders.length; col++) {
    const cell = ws.getCell(2, col + 1);
    if (subHeaders[col]) {
      cell.value = subHeaders[col];
      cell.font = { bold: true, color: { argb: whiteARGB } };
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: headerBgARGB } };
    }
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    
    // Bordes para subheaders
    let borderStyle = { top: {style: 'thin'}, bottom: {style: 'thick'} };
    
    // Bordes verticales especiales
    if (col === 0) borderStyle.left = {style: 'thick'}; // Primera columna
    if (col === subHeaders.length - 1) borderStyle.right = {style: 'thick'}; // √öltima columna
    if ([0, 1, 2, 3, 4, 5].includes(col)) borderStyle.right = {style: 'thin'}; // Separadores b√°sicos
    if ([5, 9, 13, 17, 21].includes(col)) borderStyle.right = {style: 'thick'}; // Separadores principales
    
    cell.border = borderStyle;
  }
  
  // Datos de jugadores
  finalResults.players.forEach((player, index) => {
    const row = index + 3;
    
    // Determinar color de fondo para el podio y filas alternas
    let rowFill = null;
    if (index === 0) {
      rowFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: goldARGB } }; // Oro
    } else if (index === 1) {
      rowFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: silverARGB } }; // Plata
    } else if (index === 2) {
      rowFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: bronzeARGB } }; // Bronce
    } else if (index % 2 === 1) {
      rowFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: lightGrayARGB } }; // Filas alternas
    }
    
    // NICK
    const nickCell = ws.getCell(row, 1);
    nickCell.value = player.name;
    nickCell.font = { bold: true };
    nickCell.alignment = { horizontal: 'left', vertical: 'middle' };
    if (rowFill) nickCell.fill = rowFill;
    nickCell.border = { top: {style: 'thin'}, left: {style: 'thick'}, bottom: {style: 'thin'}, right: {style: 'thin'} };
    
    // TOT (negro y negrita)
    const totCell = ws.getCell(row, 2);
    totCell.value = player.totalPoints;
    totCell.font = { bold: true, color: { argb: blackARGB } };
    totCell.alignment = { horizontal: 'center', vertical: 'middle' };
    if (rowFill) totCell.fill = rowFill;
    totCell.border = { top: {style: 'thin'}, left: {style: 'thin'}, bottom: {style: 'thin'}, right: {style: 'thick'} };
    
    // DES (en rojo y negrita)
    const desCell = ws.getCell(row, 3);
    desCell.value = player.minPoints;
    desCell.font = { bold: true, color: { argb: redARGB } };
    desCell.alignment = { horizontal: 'center', vertical: 'middle' };
    if (rowFill) desCell.fill = rowFill;
    desCell.border = { top: {style: 'thin'}, left: {style: 'thin'}, bottom: {style: 'thin'}, right: {style: 'thick'} };
    
    // PO (Palos totales) - negrita
    const poCell = ws.getCell(row, 4);
    poCell.value = player.totalPalos;
    poCell.font = { bold: true };
    poCell.alignment = { horizontal: 'center', vertical: 'middle' };
    if (rowFill) poCell.fill = rowFill;
    poCell.border = { top: {style: 'thin'}, left: {style: 'thin'}, bottom: {style: 'thin'}, right: {style: 'thick'} };
    
    // SC (Scratches totales) - negrita
    const scCell = ws.getCell(row, 5);
    scCell.value = player.totalScratches;
    scCell.font = { bold: true };
    scCell.alignment = { horizontal: 'center', vertical: 'middle' };
    if (rowFill) scCell.fill = rowFill;
    scCell.border = { top: {style: 'thin'}, left: {style: 'thin'}, bottom: {style: 'thin'}, right: {style: 'thick'} };
    
    // AC (Aces totales) - negrita
    const acCell = ws.getCell(row, 6);
    acCell.value = player.totalAces;
    acCell.font = { bold: true };
    acCell.alignment = { horizontal: 'center', vertical: 'middle' };
    if (rowFill) acCell.fill = rowFill;
    acCell.border = { top: {style: 'thin'}, left: {style: 'thin'}, bottom: {style: 'thin'}, right: {style: 'thick'} };
    
    // Datos por GP/Tem√°tica
    for (let gp = 1; gp <= 5; gp++) {
      const baseCol = 7 + ((gp - 1) * 4);
      const gpData = player.gpResults[`gp${gp}`];
      
      // Verificar si el jugador estuvo ausente en esta tem√°tica
      const wasAbsent = !gpData || (gpData.points === 0 && gpData.palos === 0 && gpData.scratches === 0 && gpData.aces === 0);
      
      // PTS (negrita para tem√°ticas)
      const ptsCell = ws.getCell(row, baseCol);
      ptsCell.value = (gpData && !wasAbsent) ? gpData.points : '';
      ptsCell.font = { bold: true };
      ptsCell.alignment = { horizontal: 'center', vertical: 'middle' };
      if (rowFill) ptsCell.fill = rowFill;
      ptsCell.border = { top: {style: 'thin'}, left: {style: 'thin'}, bottom: {style: 'thin'}, right: {style: 'thin'} };
      
      // PO (no negrita para tem√°ticas)
      const poGpCell = ws.getCell(row, baseCol + 1);
      poGpCell.value = (gpData && !wasAbsent && gpData.palos > 0) ? gpData.palos : '';
      poGpCell.alignment = { horizontal: 'center', vertical: 'middle' };
      if (rowFill) poGpCell.fill = rowFill;
      poGpCell.border = { top: {style: 'thin'}, left: {style: 'thin'}, bottom: {style: 'thin'}, right: {style: 'thin'} };
      
      // SC (no negrita para tem√°ticas)
      const scGpCell = ws.getCell(row, baseCol + 2);
      scGpCell.value = (gpData && !wasAbsent && gpData.scratches > 0) ? gpData.scratches : '';
      scGpCell.alignment = { horizontal: 'center', vertical: 'middle' };
      if (rowFill) scGpCell.fill = rowFill;
      scGpCell.border = { top: {style: 'thin'}, left: {style: 'thin'}, bottom: {style: 'thin'}, right: {style: 'thin'} };
      
      // AC (no negrita para tem√°ticas)
      const acGpCell = ws.getCell(row, baseCol + 3);
      acGpCell.value = (gpData && !wasAbsent && gpData.aces > 0) ? gpData.aces : '';
      acGpCell.alignment = { horizontal: 'center', vertical: 'middle' };
      if (rowFill) acGpCell.fill = rowFill;
      
      // Borde derecho especial para separar tem√°ticas
      const rightBorder = (gp === 5) ? {style: 'thick'} : {style: 'thick'};
      acGpCell.border = { top: {style: 'thin'}, left: {style: 'thin'}, bottom: {style: 'thin'}, right: rightBorder };
    }
  });
  
  // A√±adir bordes inferiores gruesos a la √∫ltima fila
  const lastRow = finalResults.players.length + 2;
  for (let col = 1; col <= subHeaders.length; col++) {
    const cell = ws.getCell(lastRow, col);
    if (!cell.border) cell.border = {};
    cell.border.bottom = {style: 'thick'};
  }
}
  
// PROCESO 2 GP: Totales GP
async function processTotales_GP(){
  if (competitionType!=='gp') return;
  const files = document.getElementById('fileInputTotales').files;
  if (!files || files.length === 0) return showError('Selecciona al menos un archivo Excel GP (.xlsx)');
  
  try{
    const gpData = []; // Array para almacenar datos de cada jornada GP
    fileNames = Array.from(files).map(f=>f.name);
    
    for (const file of files){
      const buffer = await file.arrayBuffer();
      const workbook = new ExcelJS.Workbook();
      await workbook.xlsx.load(buffer);
      
      const worksheet = workbook.getWorksheet('GP');
      if (!worksheet){ 
        showError(`El archivo ${file.name} no tiene hoja 'GP'`); 
        return; 
      }
      
      const jordadaData = extractGPDataFromExcel(worksheet);
      if (jordadaData) gpData.push(jordadaData);
    }
    
    if (gpData.length === 0){
      showError("No se encontraron datos v√°lidos en los archivos GP.");
      return;
    }
    
    // Procesar datos para totales
    processedData = calculateGPTotals(gpData);
    
    displayTotalesGPResults();
    document.getElementById('downloadSection').style.display='block';
    document.getElementById('downloadBtn').disabled = false;
    currentProcess='totales';
    
    showSuccess(`${fileNames.length} archivo${fileNames.length>1?'s':''} GP procesado${fileNames.length>1?'s':''} correctamente`);
    
  }catch(err){ 
    showError(`Error al procesar totales GP: ${err.message}`); 
    console.error(err);
  }
}

// Extraer datos de un Excel GP
function extractGPDataFromExcel(worksheet){
  const groups = [];
  const maxRows = worksheet.rowCount || 100;
  const maxCols = worksheet.columnCount || 50;
  
  // Buscar cabeceras de grupos en la fila 2 (despu√©s del margen)
  for (let col = 1; col <= maxCols; col++){
    const cellValue = worksheet.getCell(2, col).value;
    if (cellValue && String(cellValue).match(/GRUPO\s+[A-Z]/i)){
      const groupName = String(cellValue).trim();
      const gppCol = col + 1; // Columna GP1, GP2, etc.
      const players = [];
      
      // Leer jugadores desde la fila 3 hacia abajo
      for (let row = 3; row <= maxRows; row++){
        const nameCell = worksheet.getCell(row, col);
        const gppCell = worksheet.getCell(row, gppCol);
        
        // Si no hay nombre, parar
        if (!nameCell.value || String(nameCell.value).trim() === '') break;
        
        const name = String(nameCell.value).trim();
        const gpp = Number(gppCell.value) || 0;
        
        // Evitar filas vac√≠as
        if (name && name.length > 0){
          players.push({
            name: name.toUpperCase(),
            gpp: gpp
          });
        }
      }
      
      if (players.length > 0){
        groups.push({ group: groupName, players });
        console.log(`Encontrado ${groupName} con ${players.length} jugadores`);
      }
      
      // Saltar columnas hasta el siguiente grupo (buscar de 4 en 4)
      col += 3; // Esto permite que en la siguiente iteraci√≥n busque en col+4
    }
  }
  
  console.log(`Total grupos encontrados: ${groups.length}`);
  return groups.length > 0 ? groups : null;
}

// Calcular totales GP (GLOBAL, DESC, TOTAL) - versi√≥n mejorada
function calculateGPTotals(allJornadas){
  const playerStats = {}; // {playerName: {group, jornadas: [gpp1, gpp2, ...], global, desc, total}}
  
  // Recopilar todos los datos por jugador
  allJornadas.forEach((jornada, jornadaIndex) => {
    jornada.forEach(group => {
      group.players.forEach(player => {
        if (!playerStats[player.name]){
          playerStats[player.name] = {
            group: group.group,
            jornadas: Array(allJornadas.length).fill(0), // Inicializar con 0s
            global: 0,
            desc: 0,
            total: 0
          };
        }
        
        playerStats[player.name].jornadas[jornadaIndex] = player.gpp;
      });
    });
  });
  
  // Calcular GLOBAL, DESC y TOTAL para cada jugador
  Object.keys(playerStats).forEach(playerName => {
    const player = playerStats[playerName];
    const gppValues = player.jornadas;
    
    // GLOBAL = suma de todos los GPP
    player.global = gppValues.reduce((sum, gpp) => sum + gpp, 0);
    
    // DESC = menor valor GPP
    player.desc = Math.min(...gppValues);
    
    // TOTAL = GLOBAL - DESC
    player.total = player.global - player.desc;
  });
  
  // Organizar por grupos
  const groupedResults = {};
  Object.keys(playerStats).forEach(playerName => {
    const player = playerStats[playerName];
    if (!groupedResults[player.group]){
      groupedResults[player.group] = [];
    }
    
    groupedResults[player.group].push({
      name: playerName,
      group: player.group,
      jornadas: player.jornadas,
      global: player.global,
      desc: player.desc,
      total: player.total
    });
  });
  
  // Ordenar cada grupo (por GLOBAL si < 5 jornadas, por TOTAL si >= 5 jornadas)
  const numJornadas = allJornadas.length;
  const sortKey = numJornadas >= 5 ? 'total' : 'global';
  
  Object.keys(groupedResults).forEach(groupName => {
    groupedResults[groupName].sort((a, b) => b[sortKey] - a[sortKey]);
  });
  
  return { groups: groupedResults, numJornadas };
}

// Mostrar resultados de totales GP
function displayTotalesGPResults(){
  const resultsDiv = document.getElementById('results'); 
  resultsDiv.innerHTML='';
  
  const totalPlayers = Object.values(processedData.groups).reduce((sum, group) => sum + group.length, 0);
  
  const info = document.createElement('div'); 
  info.className='log-info';
  info.innerHTML = `<h3>üèÜ Totales GP Procesados</h3>
    <p><strong>Jornadas procesadas:</strong> ${processedData.numJornadas}</p>
    <p><strong>Grupos:</strong> ${Object.keys(processedData.groups).length}</p>
    <p><strong>Jugadores totales:</strong> ${totalPlayers}</p>
    <p><em>Ordenado por: ${processedData.numJornadas >= 5 ? 'TOTAL (mejores 4 de 5)' : 'GLOBAL (suma total)'}</em></p>
    <p><em>Pulsa "Descargar Excel" para generar el archivo</em></p>`;
  resultsDiv.appendChild(info); 
  resultsDiv.style.display='block';
}

// Descargar Excel de totales GP
async function downloadExcel_GP_Totales(){
  if (!processedData || !processedData.groups) return showError('No hay datos de totales GP procesados.');
  
  const wb = new ExcelJS.Workbook();
  wb.created = new Date();
  
  const ws = wb.addWorksheet('Totales GP', { views:[{ state:'normal', showGridLines:false }] });
  buildGPTotalsSheet(ws, processedData);
  
  const uint8 = await wb.xlsx.writeBuffer();
  const stamp = new Date().toISOString().slice(0,10);
  // Extraer nombres base de los archivos (sin extensi√≥n)
  const baseNames = fileNames.map(name => name.replace('.xlsx', '').replace('GP_', '').replace(/^\d{4}-\d{2}-\d{2}(\s+\d+)?$/, '').trim()).filter(name => name);
  const jornadasStr = baseNames.length > 0 ? baseNames.join('+') : 'Multiples';
  saveAs(new Blob([uint8], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}), `GP_Totales_${jornadasStr}.xlsx`);
  showSuccess('Excel Totales GP generado correctamente.');
}

// Construir hoja de totales GP
function buildGPTotalsSheet(ws, data){
  const marginW = widthFromPx(24);
  const nameW = widthFromPx(150);
  const numW = widthFromPx(50);
  const gpW = widthFromPx(32); // Columnas GP y PAR m√°s anchas
  const bandARGB = 'FF0B7D7D';
  const whiteARGB = 'FFFFFFFF';
  const greenDarkARGB = 'FF00B050'; // Verde m√°s claro para TOTAL
  const redARGB = 'FFCC0000'; // Rojo para DESC
  const greenClassifiedARGB = 'FF00B050'; // Verde para clasificados directos (mismo que TOTAL)
  const greenRepescaARGB = 'FF92D050'; // Verde claro para repescados
  
  ws.views = [{ state: 'normal', showGridLines: false }];
  
  // Fila vac√≠a arriba
  ws.spliceRows(1, 0, []);
  try { ws.getRow(1).height = 7.5; } catch {}
  
  const groups = Object.keys(data.groups).sort();
  const numJornadas = data.numJornadas;
  
  // Calcular columnas: margen + (TOTAL+GLOBAL+DESC+nombre+GP1-GP5+PAR) * numGrupos + separadores + margen
  const colsPerGroup = 10; // TOTAL+GLOBAL+DESC+nombre+GP1+GP2+GP3+GP4+GP5+PAR
  const separatorCols = 2; // 2 columnas vac√≠as entre grupos
  const totalCols = 1 + (colsPerGroup * groups.length) + (separatorCols * (groups.length - 1)) + 1;
  
  ws.columns = Array.from({length: totalCols}, () => ({ width: 11 }));
  
  // Configurar anchos
  ws.getColumn(1).width = marginW; // margen izq
  ws.getColumn(totalCols).width = marginW; // margen der
  
  let baseCol = 2; // Empezar en columna 2
  
  groups.forEach((groupName, groupIndex) => {
    const players = data.groups[groupName];
    
    // Configurar anchos de este grupo
    ws.getColumn(baseCol).width = numW;     // TOTAL
    ws.getColumn(baseCol + 1).width = numW; // GLOBAL  
    ws.getColumn(baseCol + 2).width = numW; // DESC
    ws.getColumn(baseCol + 3).width = nameW; // nombre
    ws.getColumn(baseCol + 4).width = gpW;  // GP1
    ws.getColumn(baseCol + 5).width = gpW;  // GP2
    ws.getColumn(baseCol + 6).width = gpW;  // GP3
    ws.getColumn(baseCol + 7).width = gpW;  // GP4
    ws.getColumn(baseCol + 8).width = gpW;  // GP5
    ws.getColumn(baseCol + 9).width = gpW; // PAR (mismo ancho que GP)
    
    // Cabecera del grupo
    const headers = ['TOTAL', 'GLOBAL', 'DESC', groupName, 'GP1', 'GP2', 'GP3', 'GP4', 'GP5', 'PAR'];
    for (let col = 0; col < headers.length; col++){
      const cell = ws.getCell(2, baseCol + col);
      cell.value = headers[col];
      cell.font = { bold: true, color: { argb: whiteARGB } };
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: bandARGB } };
      cell.alignment = { horizontal: col === 3 ? 'left' : 'center', vertical: 'middle' };
      cell.border = { 
        top: {style: 'thin'}, left: {style: 'thin'}, 
        bottom: {style: 'thin'}, right: {style: 'thin'} 
      };
    }
    
    // Calcular repescados si estamos en jornada 5+
    let repescados = [];
    const isSingleGroup = groups.length === 1; // Detectar si hay un solo grupo
    
    if (numJornadas >= 5) {
      // Encontrar jugadores que no est√°n en top 12 pero cumplen criterios de repesca
      const noClasificados = players.slice(12); // Jugadores del puesto 13 en adelante
      const candidatosRepesca = noClasificados.filter(player => {
        const partidasJugadas = player.jornadas.filter(gpp => gpp > 0).length;
        // Si hay un solo grupo, no aplicar restricci√≥n de partidas m√≠nimas
        return isSingleGroup || partidasJugadas >= 4;
      });
      
      // Ordenar candidatos por TOTAL y tomar m√°ximo 6
      candidatosRepesca.sort((a, b) => b.total - a.total);
      repescados = candidatosRepesca.slice(0, 6).map(p => p.name);
    }
    
    // Datos de jugadores
    players.forEach((player, playerIndex) => {
      const currentRow = 3 + playerIndex;
      
      // Determinar color de fondo para clasificados
      let nameBackgroundColor = null;
      if (numJornadas >= 5) {
        if (isSingleGroup) {
          // Si hay un solo grupo, todos los jugadores clasifican con color verde
          nameBackgroundColor = greenClassifiedARGB;
        } else {
          // L√≥gica normal para m√∫ltiples grupos
          if (playerIndex < 12) {
            // Top 12 - clasificados directos
            nameBackgroundColor = greenClassifiedARGB;
          } else if (repescados.includes(player.name)) {
            // Repescados
            nameBackgroundColor = greenRepescaARGB;
          }
        }
      }
      
      // TOTAL
      const totalCell = ws.getCell(currentRow, baseCol);
      totalCell.value = player.total;
      totalCell.alignment = { horizontal: 'center', vertical: 'middle' };
      totalCell.font = { bold: true, color: { argb: greenDarkARGB } };
      
      // GLOBAL  
      const globalCell = ws.getCell(currentRow, baseCol + 1);
      globalCell.value = player.global;
      globalCell.alignment = { horizontal: 'center', vertical: 'middle' };
      globalCell.font = { bold: true };
      
      // DESC
      const descCell = ws.getCell(currentRow, baseCol + 2);
      descCell.value = player.desc;
      descCell.alignment = { horizontal: 'center', vertical: 'middle' };
      descCell.font = { bold: true, color: { argb: redARGB } };
      
      // Nombre (con color de fondo si est√° clasificado)
      const nameCell = ws.getCell(currentRow, baseCol + 3);
      nameCell.value = player.name;
      nameCell.alignment = { horizontal: 'left', vertical: 'middle' };
      if (nameBackgroundColor) {
        nameCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: nameBackgroundColor } };
        // Texto en negro para mejor contraste
        nameCell.font = { color: { argb: 'FF000000' } };
      }
      
      // GP1-GP5 (mostrar siempre valores, incluyendo 0)
      for (let i = 0; i < 5; i++){
        const gppValue = i < player.jornadas.length ? player.jornadas[i] : 0;
        const gpCell = ws.getCell(currentRow, baseCol + 4 + i);
        gpCell.value = gppValue;
        gpCell.alignment = { horizontal: 'center', vertical: 'middle' };
        gpCell.font = { bold: true };
      }
      
      // PAR (Participaci√≥n)
      const partidasJugadas = player.jornadas.filter(gpp => gpp > 0).length;
      const parCell = ws.getCell(currentRow, baseCol + 9);
      parCell.value = `${partidasJugadas}/${numJornadas}`;
      parCell.alignment = { horizontal: 'center', vertical: 'middle' };
      parCell.font = { bold: false }; // Sin negrita para PAR
      
      // L√≠nea recta debajo del jugador 12
      if (playerIndex === 11) { // Jugador 12 (√≠ndice 11)
        // Dibujar l√≠nea en las columnas de separaci√≥n (si no es el √∫ltimo grupo)
        if (groupIndex < groups.length - 1) {
          const lineRow = currentRow; // Subir una fila (sin +1)
          const separatorStartCol = baseCol + colsPerGroup;
          // Solo la segunda columna separadora (la de la derecha)
          const lineCell = ws.getCell(lineRow, separatorStartCol + 1);
          lineCell.border = { 
            bottom: { style: 'thick', color: { argb: 'FF000000' } } 
          };
        }
      }
    });
    
    // Mover a la siguiente posici√≥n de grupo
    baseCol += colsPerGroup;
    if (groupIndex < groups.length - 1) {
      // A√±adir separadores (2 columnas vac√≠as)
      ws.getColumn(baseCol).width = widthFromPx(10);     // Primera columna separadora
      ws.getColumn(baseCol + 1).width = widthFromPx(22); // Segunda columna separadora (m√°s ancha para la l√≠nea)
      baseCol += separatorCols;
    }
  });
  
  // Fila vac√≠a abajo
  ws.addRow([]);

// NUEVO: Si hay un solo grupo, colorear todos los jugadores como clasificados
  if (groups.length === 1) {
    console.log('Solo hay un grupo detectado - todos los jugadores clasifican');
    
    const singleGroup = groups[0];
    const players = data.groups[singleGroup];
    const qualifiedColor = { type: 'pattern', pattern: 'solid', fgColor: { argb: greenClassifiedARGB } }; // Usar el mismo verde que TOTAL
    
    // Colorear todas las filas de jugadores (empiezan en fila 3)
    players.forEach((player, index) => {
      const row = 3 + index; // Los datos empiezan en fila 3
      
      // Colorear todas las celdas de la fila del jugador (desde TOTAL hasta PAR)
      for (let col = 0; col < 10; col++) { // 10 columnas: TOTAL, GLOBAL, DESC, nombre, GP1-GP5, PAR
        const cell = ws.getCell(row, baseCol + col);
        if (cell.value !== null && cell.value !== undefined && cell.value !== '') {
          cell.fill = qualifiedColor;
        }
      }
    });
    
    // A√±adir nota explicativa al final
    const noteRow = 3 + players.length + 2;
    const noteCell = ws.getCell(noteRow, baseCol + 3); // En la columna del nombre
    noteCell.value = '* Todos los jugadores clasifican (grupo √∫nico)';
    noteCell.font = { italic: true, size: 10, color: { argb: 'FF666666' } };
  } 

}

/* ================================================================
   ======================== BLOQUE COPA ============================
   ================================================================ */

function processJornada_COPA(){
  const files = document.getElementById('fileInputJornada').files;
  if (!files || files.length === 0) return showError('Selecciona un archivo de log de Copa');
  if (files.length > 1) return showError('Para la Copa solo se puede procesar un archivo');
  
  const file = files[0];
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const content = e.target.result;
      const data = parseCopaLogFile(content); // Usar la funci√≥n espec√≠fica de Copa
      processedData = [data];
      
      displayResults(processedData);
      document.getElementById('downloadSection').style.display='block';
      document.getElementById('downloadBtn').disabled = false;
      currentProcess='jornada';
      showSuccess('Archivo de Copa procesado correctamente');
    } catch(err) {
      showError(`Error al procesar Copa: ${err.message}`);
    }
  };
  reader.readAsText(file);
}

function parseCopaLogFile(content) {
  const lines = content.split('\n').map(l => l.trim()).filter(Boolean);
  const teamStart = lines.findIndex(l => l.toUpperCase().includes('CLASIFICACION EQUIPOS'));
  const playerStart = lines.findIndex(l => l.toUpperCase().includes('CLASIFICACION INDIVIDUAL'));
  if (teamStart === -1 || playerStart === -1) throw new Error('Secciones no encontradas');

  // Extraer equipos y sus puntos
  const teams = {}, teamOrder = [];
  for (let i = teamStart + 1; i < playerStart; i++) {
    const m = /^(.*?)\s+(-?\d+)\s*$/.exec(lines[i]);
    if (!m) continue;
    const team = m[1].trim();
    const points = parseInt(m[2], 10);
    teams[team] = points;
    teamOrder.push(team);
  }

  // Extraer jugadores
  const players = [];
  for (let i = playerStart + 1; i < lines.length; i++) {
    const line = lines[i];
    if (!line) continue;
    const parts = line.split(/\s+/);
    if (parts.length < 2) continue;
    const name = parts[0];
    const points = parseInt(parts[1], 10);
    players.push({
      name: name.toUpperCase(),
      points: line.toUpperCase().includes('NO ESTUVO PRESENTE') ? null : points,
      aces: parseInt((line.match(/Aces:\s*(\d+)/i) || [0, 0])[1], 10),
      scratches: parseInt((line.match(/Scr:\s*(\d+)/i) || [0, 0])[1], 10),
      palos: parseInt((line.match(/Palos:\s*(\d+)/i) || [0, 0])[1], 10),
      absent: line.toUpperCase().includes('NO ESTUVO PRESENTE')
    });
  }

  // Asignar jugadores a equipos usando orden alfab√©tico
  const teamsAlpha = Object.keys(teams).sort((a, b) => a.localeCompare(b, 'es', { sensitivity: 'base' }));
  
  if (players.length > 0) {
    let currentTeamIndex = 0;
    let prevNick = '';
    
    for (let i = 0; i < players.length; i++) {
      const curr = players[i];
      
      // Si el nombre actual es alfab√©ticamente menor que el anterior, cambiar de equipo
      if (i > 0 && curr.name.localeCompare(prevNick, 'es', { sensitivity: 'base' }) < 0) {
        currentTeamIndex++;
        if (currentTeamIndex >= teamsAlpha.length) {
          currentTeamIndex = teamsAlpha.length - 1; // No exceder el n√∫mero de equipos
        }
      }
      
      curr.team = teamsAlpha[currentTeamIndex] || 'SinEquipo';
      prevNick = curr.name;
    }
  }

  return { teams, teamOrder, players };
}
  
async function downloadExcel_COPA(){
  if (!processedData || processedData.length === 0) return showError('No hay datos procesados de Copa');
  
  const wb = new ExcelJS.Workbook();
  wb.created = new Date();
  
  const ws = wb.addWorksheet('Copa Final', { views:[{ state:'normal', showGridLines:false }] });
  buildCopaSheet(ws, processedData[0]);
  
  const uint8 = await wb.xlsx.writeBuffer();
  saveAs(new Blob([uint8], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}), `Copa_Final.xlsx`);
  showSuccess('Excel Copa generado correctamente.');
}

function buildCopaSheet(ws, data) {
  // Preparar datos de equipos ordenados por puntuaci√≥n
  const teams = data.teamOrder.map(teamName => ({
    name: teamName,
    points: data.teams[teamName] || 0,
    players: data.players
      .filter(p => p.team === teamName && !p.absent)
      .sort((a,b) => {
        const pointsDiff = (b.points||0) - (a.points||0);
        if (pointsDiff !== 0) return pointsDiff;
        
        const acesDiff = (b.aces||0) - (a.aces||0);
        if (acesDiff !== 0) return acesDiff;
        
        const scratchesDiff = (b.scratches||0) - (a.scratches||0);
        if (scratchesDiff !== 0) return scratchesDiff;
        
        return (b.palos||0) - (a.palos||0);
      }),
    colors: COLORES_EQUIPOS[teamName.replace(/\s+(I|II)$/, '')] || { bg:'#CCCCCC', fg:'#000000' }
  })).sort((a,b) => b.points - a.points);
  
  // Encontrar mejores estad√≠sticas globales
  const allPlayers = data.players.filter(p => !p.absent);
  const bestStats = {
    points: Math.max(...allPlayers.map(p => p.points || 0)),
    palos: Math.max(...allPlayers.map(p => p.palos || 0)),
    scratches: Math.max(...allPlayers.map(p => p.scratches || 0)),
    aces: Math.max(...allPlayers.map(p => p.aces || 0))
  };
  
  ws.views = [{ state: 'normal', showGridLines: false }];
  let currentRow = 1;
  
  for (let i = 0; i < teams.length; i += 3) {
    const teamPair = teams.slice(i, i + 3);
    
    // Calcular totales de equipos
    const teamTotals = teamPair.map(team => {
      const totals = { scratches: 0, palos: 0, aces: 0 };
      team.players.forEach(player => {
        totals.scratches += player.scratches || 0;
        totals.palos += player.palos || 0;
        totals.aces += player.aces || 0;
      });
      return totals;
    });
    
    // Fila de headers con posiciones oro/plata/bronce
    const headerRow = [''];
    teamPair.forEach((team, idx) => {
      const globalPosition = i + idx;
      let positionText = '';
      
      if (globalPosition === 0) positionText = '1¬∫';
      else if (globalPosition === 1) positionText = '2¬∫'; 
      else if (globalPosition === 2) positionText = '3¬∫';
      
      headerRow.push(positionText, 'PU', 'PO', 'SC', 'AC');
      if (idx < teamPair.length - 1) headerRow.push('');
    });
    ws.getRow(currentRow).values = headerRow;
    
    // Fila de totales de equipos
    const totalsRow = [''];
    teamPair.forEach((team, idx) => {
      totalsRow.push(team.name, team.points, teamTotals[idx].palos, teamTotals[idx].scratches, teamTotals[idx].aces);
      if (idx < teamPair.length - 1) totalsRow.push('');
    });
    ws.getRow(currentRow + 1).values = totalsRow;
    
    // Aplicar formato a headers y totales
    let col = 2;
    teamPair.forEach((team, teamIdx) => {
      const globalPosition = i + teamIdx;
      
      // Formato headers
      for (let i = 0; i < 5; i++) {
        const headerCell = ws.getCell(currentRow, col + i);
        headerCell.font = { bold: false, size: 13 };
        headerCell.alignment = { horizontal: 'center', vertical: 'center' };
        
        // Aplicar oro/plata/bronce a la primera celda
        if (i === 0 && globalPosition < 3) {
          headerCell.font = { bold: true, color: { argb: 'FF000000' } };
          headerCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { 
            argb: globalPosition === 0 ? 'FFD700' : (globalPosition === 1 ? 'FFC0C0C0' : 'FFCD7F32') 
          }};
        }
      }
      
      // Formato totales de equipos
      for (let i = 0; i < 5; i++) {
        const totalCell = ws.getCell(currentRow + 1, col + i);
        if (i === 0) {
          totalCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: team.colors.bg.replace('#','FF') } };
          totalCell.font = { color: { argb: team.colors.fg.replace('#','FF') }, bold: true, size: 14 };
        } else {
          totalCell.font = { bold: true, size: 12 }; // Todos los valores del equipo en negrita
        }
        totalCell.alignment = { horizontal: 'center', vertical: 'center' };
      }
      
      col += (teamIdx < teamPair.length - 1) ? 6 : 5;
    });
    
    currentRow += 2;
    
    // Datos de jugadores
    let rowsWritten = 0;
    for (let playerIdx = 0; playerIdx < Math.max(...teamPair.map(t => t.players.length)); playerIdx++) {
      const hasAnyPlayer = teamPair.some(team => playerIdx < team.players.length);
      if (!hasAnyPlayer) break;
      
      const playerRow = [''];
      teamPair.forEach((team, teamIdx) => {
        const player = team.players[playerIdx];
        if (player) {
          const valOrBlank = (v) => (v === 0) ? '' : v;
          
          playerRow.push(
            player.name,
            player.points || 0,
            valOrBlank(player.palos || 0),
            valOrBlank(player.scratches || 0),
            valOrBlank(player.aces || 0)
          );
        } else {
          playerRow.push('', '', '', '', '');
        }
        if (teamIdx < teamPair.length - 1) playerRow.push('');
      });
      
      ws.getRow(currentRow + rowsWritten).values = playerRow;
      
      // Aplicar formato con destacados amarillos
      let playerCol = 2;
      teamPair.forEach((team, teamIdx) => {
        const player = team.players[playerIdx];
        if (player) {
          const stats = [player.points || 0, player.palos || 0, player.scratches || 0, player.aces || 0];
          const bests = [bestStats.points, bestStats.palos, bestStats.scratches, bestStats.aces];
          
          for (let j = 0; j < 5; j++) {
            const cell = ws.getCell(currentRow + rowsWritten, playerCol + j);
            cell.alignment = { horizontal: j === 0 ? 'left' : 'center', vertical: 'center' };
            
            // Destacar mejores estad√≠sticas en amarillo
            if (j === 0) {
              // Nombre - amarillo si tiene los mejores puntos
              if ((player.points || 0) === bestStats.points) {
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFF00' } };
              }
            } else {
              // Estad√≠sticas - amarillo si es el mejor valor
              const statValue = stats[j - 1];
              const bestValue = bests[j - 1];
              if (statValue === bestValue && statValue > 0) {
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFF00' } };
              }
            }
          }
        }
        playerCol += (teamIdx < teamPair.length - 1) ? 6 : 5;
      });
      
      rowsWritten++;
    }
    
    // Solo 1 fila en blanco entre bloques (no 2)
    currentRow += rowsWritten + 1;
  }
  
  // Configurar anchos
  if (teams.length > 0) {
    const widths = [widthFromPx(20)]; // margen izquierdo
    // Configurar para m√°ximo 3 equipos por fila
    for (let i = 0; i < 3; i++) {
      widths.push(widthFromPx(121), widthFromPx(35), widthFromPx(35), widthFromPx(35), widthFromPx(35));
      if (i < 2) widths.push(widthFromPx(42)); // separador entre equipos
    }
    
    // Separaci√≥n y ranking individual
    widths.push(widthFromPx(20)); // separaci√≥n
    widths.push(widthFromPx(20)); // separaci√≥n adicional
    widths.push(widthFromPx(120)); // JUGADOR
    widths.push(widthFromPx(35));  // PU
    widths.push(widthFromPx(35));  // PO
    widths.push(widthFromPx(35));  // SC
    widths.push(widthFromPx(35));  // AC
    
    ws.columns = widths.map(w => ({ width: w }));
  }

  // A√±adir ranking individual a la derecha (empezar en fila 1)
  addIndividualRanking(ws, allPlayers, teams, 1);
  
  ws.spliceRows(1, 0, []);
  ws.addRow([]);
}

function addIndividualRanking(ws, allPlayers, teams, startRowParam = 1) {
  // Top 20 jugadores por puntos
  const topPlayers = allPlayers
    .sort((a,b) => {
      const pointsDiff = (b.points||0) - (a.points||0);
      if (pointsDiff !== 0) return pointsDiff;
      
      const acesDiff = (b.aces||0) - (a.aces||0);
      if (acesDiff !== 0) return acesDiff;
      
      const scratchesDiff = (b.scratches||0) - (a.scratches||0);
      if (scratchesDiff !== 0) return scratchesDiff;
      
      return (b.palos||0) - (a.palos||0);
    })
    .slice(0, 20);
  
  const startCol = 21; // 2 columnas m√°s a la derecha
  let currentRow = startRowParam; // Usar el par√°metro pasado
  
  // Headers del ranking
  const headers = ['JUGADOR', 'PU', 'PO', 'SC', 'AC'];
  headers.forEach((header, i) => {
    const cell = ws.getCell(currentRow, startCol + i);
    cell.value = header;
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
  });
  
  currentRow++;
  
  // Datos de jugadores
  topPlayers.forEach(player => {
    const team = teams.find(t => t.name === player.team);
    const baseTeamName = player.team.replace(/\s+(I|II)$/, '');
    const teamColors = COLORES_EQUIPOS[baseTeamName] || { bg: '#CCCCCC', fg: '#000000' };
    
    // Jugador con colores del equipo y centrado
    const playerCell = ws.getCell(currentRow, startCol);
    playerCell.value = player.name;
    playerCell.font = { color: { argb: teamColors.fg.replace('#','FF') } };
    playerCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: teamColors.bg.replace('#','FF') } };
    playerCell.alignment = { horizontal: 'center', vertical: 'middle' };
    
    // Estad√≠sticas: PU, PO, SC, AC
    const stats = [
      player.points || 0,
      player.palos || 0, 
      player.scratches || 0,
      player.aces || 0
    ];
    
    stats.forEach((stat, i) => {
      const cell = ws.getCell(currentRow, startCol + 1 + i);
      // Solo mostrar valores > 0, excepto para PU (puntos) que siempre se muestra
      cell.value = (i === 0 || stat > 0) ? stat : '';
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
    });
    
    currentRow++;
  });
}

function buildTeamGroup(ws, teams, bestStats, startRow) {
  // Cabeceras de equipos
  teams.forEach((team, idx) => {
    const baseCol = 2 + (idx * 5); // 5 columnas por equipo
    
    // Nombre del equipo con sus puntos
    const teamCell = ws.getCell(startRow, baseCol);
    teamCell.value = team.name;
    teamCell.font = { bold: true, color: { argb: team.colors.fg.replace('#','FF') } };
    teamCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: team.colors.bg.replace('#','FF') } };
    teamCell.alignment = { horizontal: 'left', vertical: 'middle' };
    
    // Puntos del equipo
    const pointsCell = ws.getCell(startRow, baseCol + 1);
    pointsCell.value = team.points;
    pointsCell.font = { bold: true };
    pointsCell.alignment = { horizontal: 'center', vertical: 'middle' };
  });
  
  // Headers de estad√≠sticas
  const headerRow = startRow + 1;
  teams.forEach((team, idx) => {
    const baseCol = 2 + (idx * 5);
    ws.getCell(headerRow, baseCol).value = '';
    ws.getCell(headerRow, baseCol + 1).value = 'Puntos';
    ws.getCell(headerRow, baseCol + 2).value = 'Scratches';
    ws.getCell(headerRow, baseCol + 3).value = 'Palos';
    ws.getCell(headerRow, baseCol + 4).value = 'Aces';
    
    // Estilo headers
    for (let i = 1; i < 5; i++) {
      const cell = ws.getCell(headerRow, baseCol + i);
      cell.font = { bold: false, size: 13 };
      cell.alignment = { horizontal: 'center', vertical: 'center' };
      cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
    }
  });
  
  // Datos de jugadores (m√°ximo 4 filas)
  let currentRow = headerRow + 1;
  for (let playerRow = 0; playerRow < 4; playerRow++) {
    teams.forEach((team, teamIdx) => {
      const baseCol = 2 + (teamIdx * 5);
      const player = team.players[playerRow];
      
      if (player) {
        // Nombre jugador
        const nameCell = ws.getCell(currentRow, baseCol);
        nameCell.value = player.name;
        nameCell.font = { color: { argb: team.colors.fg.replace('#','FF') } };
        nameCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: team.colors.bg.replace('#','FF') } };
        nameCell.alignment = { horizontal: 'left', vertical: 'center' };
        nameCell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        
        // Puntos
        const pointsCell = ws.getCell(currentRow, baseCol + 1);
        pointsCell.value = player.points || 0;
        pointsCell.alignment = { horizontal: 'center', vertical: 'center' };
        pointsCell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        if ((player.points || 0) === bestStats.points) {
          pointsCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFF00' } };
          nameCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFF00' } };
          nameCell.font = { color: { argb: 'FF000000' } }; // Texto negro sobre amarillo
        }
        
        // Scratches
        const scrCell = ws.getCell(currentRow, baseCol + 2);
        scrCell.value = player.scratches || 0;
        scrCell.alignment = { horizontal: 'center', vertical: 'center' };
        scrCell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        if ((player.scratches || 0) === bestStats.scratches && bestStats.scratches > 0) {
          scrCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFF00' } };
        }
        
        // Palos
        const palosCell = ws.getCell(currentRow, baseCol + 3);
        palosCell.value = player.palos || 0;
        palosCell.alignment = { horizontal: 'center', vertical: 'center' };
        palosCell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        if ((player.palos || 0) === bestStats.palos && bestStats.palos > 0) {
          palosCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFF00' } };
        }
        
        // Aces
        const acesCell = ws.getCell(currentRow, baseCol + 4);
        acesCell.value = player.aces || 0;
        acesCell.alignment = { horizontal: 'center', vertical: 'center' };
        acesCell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        if ((player.aces || 0) === bestStats.aces && bestStats.aces > 0) {
          acesCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFF00' } };
        }
      }
    });
    currentRow++;
  }
  
  return currentRow;
}

function buildIndividualRanking(ws, allPlayers, teams) {
  const startCol = 18; // Columna R (despu√©s de los equipos)
  let currentRow = 2;
  
  // Headers del ranking individual
  ws.getCell(currentRow, startCol).value = 'EQUIPO';
  ws.getCell(currentRow, startCol + 1).value = 'JUGADOR';
  ws.getCell(currentRow, startCol + 2).value = 'PU';
  ws.getCell(currentRow, startCol + 3).value = 'PO';
  ws.getCell(currentRow, startCol + 4).value = 'SC';
  ws.getCell(currentRow, startCol + 5).value = 'AC';
  
  // Estilo headers
  for (let i = 0; i < 6; i++) {
    const cell = ws.getCell(currentRow, startCol + i);
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
  }
  
  currentRow++;
  
  // Datos del ranking individual
  allPlayers.forEach(player => {
    const team = teams.find(t => t.name === player.team);
    const colors = team ? team.colors : { bg: '#CCCCCC', fg: '#000000' };
    
    // Equipo
    const teamCell = ws.getCell(currentRow, startCol);
    teamCell.value = player.team;
    teamCell.font = { color: { argb: colors.fg.replace('#','FF') } };
    teamCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: colors.bg.replace('#','FF') } };
    teamCell.alignment = { horizontal: 'left', vertical: 'center' };
    teamCell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
    
    // Jugador
    const playerCell = ws.getCell(currentRow, startCol + 1);
    playerCell.value = player.name;
    playerCell.alignment = { horizontal: 'left', vertical: 'center' };
    playerCell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
    
    // Estad√≠sticas
    const stats = [
      player.points || 0,
      player.palos || 0, 
      player.scratches || 0,
      player.aces || 0
    ];
    
    for (let i = 0; i < 4; i++) {
      const cell = ws.getCell(currentRow, startCol + 2 + i);
      cell.value = stats[i];
      cell.alignment = { horizontal: 'center', vertical: 'center' };
      cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
    }
    
    currentRow++;
  });
}

/* ================================================================
   ======================== BLOQUE MASTER ==========================
   ================================================================ */

function processJornada_MASTER(){
  const files = document.getElementById('fileInputJornada').files;
  if (!files || files.length === 0) return showError('Selecciona un archivo de log de M√°ster');
  if (files.length > 1) return showError('Para el M√°ster solo se puede procesar un archivo');
  
  const file = files[0];
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const content = e.target.result;
      const data = parseMasterLogFile(content);
      processedData = [data];
      
      displayResults(processedData);
      document.getElementById('downloadSection').style.display='block';
      document.getElementById('downloadBtn').disabled = false;
      currentProcess='jornada';
      showSuccess('Archivo de M√°ster procesado correctamente');
    } catch(err) {
      showError(`Error al procesar M√°ster: ${err.message}`);
    }
  };
  reader.readAsText(file);
}

function parseMasterLogFile(content) {
  const lines = content.split('\n').map(l => l.trim()).filter(Boolean);
  const teamStart = lines.findIndex(l => l.toUpperCase().includes('CLASIFICACION EQUIPOS'));
  const playerStart = lines.findIndex(l => l.toUpperCase().includes('CLASIFICACION INDIVIDUAL'));
  if (teamStart === -1 || playerStart === -1) throw new Error('Secciones no encontradas');

  // Extraer equipos con puntuaciones
  const teams = {}, teamOrder = [];
  for (let i = teamStart + 1; i < playerStart; i++) {
    const m = /^(.*?)\s+(-?\d+)\s*$/.exec(lines[i]);
    if (!m) continue;
    let teamName = m[1].trim();
    const points = parseInt(m[2], 10);
    
    // Convertir "1" y "2" a "I" y "II"
    teamName = teamName.replace(/\s+1$/, ' I').replace(/\s+2$/, ' II');
    
    teams[teamName] = points;
    teamOrder.push(teamName);
  }

  // Extraer jugadores
  const players = [];
  for (let i = playerStart + 1; i < lines.length; i++) {
    const line = lines[i];
    if (!line) continue;
    const parts = line.split(/\s+/);
    if (parts.length < 2) continue;
    const name = parts[0];
    const points = parseInt(parts[1], 10);
    players.push({
      name: name.toUpperCase(),
      points: line.toUpperCase().includes('NO ESTUVO PRESENTE') ? null : points,
      aces: parseInt((line.match(/Aces:\s*(\d+)/i) || [0,0])[1], 10),
      scratches: parseInt((line.match(/Scr:\s*(\d+)/i) || [0,0])[1], 10),
      palos: parseInt((line.match(/Palos:\s*(\d+)/i) || [0,0])[1], 10),
      absent: line.toUpperCase().includes('NO ESTUVO PRESENTE')
    });
  }

  // Asignar jugadores a equipos usando la nueva l√≥gica sistem√°tica
  assignPlayersToTeamsSystematic(players, teams);

  return { teams, teamOrder, players };
}

function assignPlayersToTeamsSystematic(players, teams) {
  // Obtener equipos base en orden alfab√©tico
  const baseTeams = getBaseTeamsAlphabetical(teams);
  console.log('Equipos base detectados:', baseTeams);
  
  let currentPlayerIndex = 0;
  const manualAssignments = [];
  
  // Procesar cada equipo base en orden alfab√©tico
  for (const baseTeam of baseTeams) {
    console.log(`\nProcesando equipo: ${baseTeam}`);
    
    const subteams = getSubteamsForBase(baseTeam, teams);
    console.log(`Subequipos encontrados:`, subteams);
    
    const maxPlayers = subteams.length * 2;
    
    // Recopilar jugadores candidatos hasta detectar cambio de equipo
    const candidatePlayers = [];
    let tempIndex = currentPlayerIndex;
    
    while (tempIndex < players.length && candidatePlayers.length < maxPlayers) {
      const currentPlayer = players[tempIndex];
      
      // Verificar si hay salto alfab√©tico (cambio de equipo)
      if (candidatePlayers.length > 0) {
        const lastPlayer = candidatePlayers[candidatePlayers.length - 1];
        if (isAlphabeticalJump(lastPlayer.name, currentPlayer.name)) {
          console.log(`Salto alfab√©tico detectado: ${lastPlayer.name} -> ${currentPlayer.name}, cambiando de equipo`);
          break;
        }
      }
      
      candidatePlayers.push(currentPlayer);
      tempIndex++;
    }
    
    console.log(`Jugadores candidatos para ${baseTeam}:`, candidatePlayers.map(p => `${p.name}(${p.points})`));
    
    // Asignar jugadores
    const result = assignCandidatesToSubteams(candidatePlayers, subteams, teams, baseTeam);
    
    if (result.success) {
      console.log(`Asignaci√≥n autom√°tica exitosa para ${baseTeam}`);
    } else {
      console.log(`Asignaci√≥n manual requerida para ${baseTeam}`);
      manualAssignments.push(result.manualAssignment);
    }
    
    currentPlayerIndex = tempIndex;
  }
  
  // Manejar asignaciones manuales si las hay
  if (manualAssignments.length > 0) {
    return new Promise((resolve) => {
      handleManualAssignments(manualAssignments, resolve);
    });
  }
  
  return Promise.resolve();
}

function isAlphabeticalJump(prevName, currentName) {
  // Funci√≥n para obtener el primer car√°cter efectivo para comparaci√≥n alfab√©tica
  const getFirstChar = (name) => {
    // Los caracteres especiales ^ y [ van antes que las letras
    const firstChar = name.charAt(0).toLowerCase();
    if (firstChar === '^' || firstChar === '[') {
      return firstChar;
    }
    return firstChar;
  };
  
  const prevChar = getFirstChar(prevName);
  const currentChar = getFirstChar(currentName);
  
  // Si el car√°cter actual es alfab√©ticamente menor que el anterior, hay salto
  return currentChar < prevChar;
}

function getBaseTeamsAlphabetical(teams) {
  const baseTeams = new Set();
  
  for (const teamName of Object.keys(teams)) {
    const baseTeam = teamName.replace(/\s+(I|II)$/, '');
    baseTeams.add(baseTeam);
  }
  
  return Array.from(baseTeams).sort((a, b) => 
    a.localeCompare(b, 'es', { sensitivity: 'base' })
  );
}

function getSubteamsForBase(baseTeam, teams) {
  const subteams = [];
  
  if (teams[`${baseTeam} I`] !== undefined) {
    subteams.push(`${baseTeam} I`);
  }
  if (teams[`${baseTeam} II`] !== undefined) {
    subteams.push(`${baseTeam} II`);
  }
  
  if (subteams.length === 0 && teams[baseTeam] !== undefined) {
    subteams.push(baseTeam);
  }
  
  return subteams;
}

function assignCandidatesToSubteams(candidates, subteams, teams, baseTeam) {
  if (candidates.length === 0) {
    return { success: true };
  }
  
  // Caso 1: Solo un subequipo
  if (subteams.length === 1) {
    if (candidates.length <= 2) {
      candidates.forEach(player => {
        player.team = subteams[0];
      });
      return { success: true };
    } else {
      return { success: false, error: 'Demasiados jugadores para un subequipo' };
    }
  }
  
  // Caso 2: Dos subequipos - buscar todas las combinaciones v√°lidas
  if (subteams.length === 2) {
    const team1Score = teams[subteams[0]];
    const team2Score = teams[subteams[1]];
    
    const validCombinations = findAllValidCombinations(candidates, team1Score, team2Score);
    
    if (validCombinations.length === 1) {
      // Solo una combinaci√≥n v√°lida - asignaci√≥n autom√°tica
      const combination = validCombinations[0];
      combination.team1.forEach(player => {
        player.team = subteams[0];
      });
      combination.team2.forEach(player => {
        player.team = subteams[1];
      });
      
      return { success: true };
    } else if (validCombinations.length > 1) {
      // M√∫ltiples combinaciones v√°lidas - requiere asignaci√≥n manual
      return {
        success: false,
        manualAssignment: {
          baseTeam: baseTeam,
          subteams: subteams,
          candidates: candidates,
          validCombinations: validCombinations,
          scores: { team1: team1Score, team2: team2Score }
        }
      };
    } else {
      return { success: false, error: 'No se encontr√≥ combinaci√≥n v√°lida' };
    }
  }
  
  return { success: false, error: 'Configuraci√≥n de subequipos no v√°lida' };
}

function findAllValidCombinations(players, team1Score, team2Score) {
  const validCombinations = [];
  const totalPlayers = players.length;
  
  // Filtrar jugadores v√°lidos (no ausentes)
  const validPlayers = players.filter(p => p.points !== null);
  
  if (validPlayers.length === 0) return [];
  
  // Probar todas las combinaciones posibles
  for (let i = 0; i < Math.pow(2, validPlayers.length); i++) {
    const team1 = [];
    const team2 = [];
    
    for (let j = 0; j < validPlayers.length; j++) {
      if (i & (1 << j)) {
        team1.push(validPlayers[j]);
      } else {
        team2.push(validPlayers[j]);
      }
    }
    
    // Verificar l√≠mites (m√°ximo 2 jugadores por equipo)
    if (team1.length <= 2 && team2.length <= 2 && team1.length > 0 && team2.length > 0) {
      const sum1 = team1.reduce((sum, p) => sum + (p.points || 0), 0);
      const sum2 = team2.reduce((sum, p) => sum + (p.points || 0), 0);
      
      if (sum1 === team1Score && sum2 === team2Score) {
        // Agregar jugadores ausentes si los hay
        const fullTeam1 = [...team1];
        const fullTeam2 = [...team2];
        
        const absentPlayers = players.filter(p => p.points === null);
        absentPlayers.forEach((player, index) => {
          if (index % 2 === 0 && fullTeam1.length < 2) {
            fullTeam1.push(player);
          } else if (fullTeam2.length < 2) {
            fullTeam2.push(player);
          } else if (fullTeam1.length < 2) {
            fullTeam1.push(player);
          }
        });
        
        validCombinations.push({
          team1: fullTeam1,
          team2: fullTeam2
        });
      }
    }
  }
  
  return validCombinations;
}

function handleManualAssignments(manualAssignments, callback) {
  // Crear interfaz para asignaci√≥n manual
  const container = document.createElement('div');
  container.id = 'manualAssignmentsModal';
  container.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center;
    z-index: 1000;
  `;
  
  const modal = document.createElement('div');
  modal.style.cssText = `
    background: white; padding: 30px; border-radius: 10px; max-width: 800px; width: 90%;
    max-height: 80%; overflow-y: auto;
  `;
  
  modal.innerHTML = `
    <h3>üéØ Asignaci√≥n Manual de Equipos</h3>
    <p>Los siguientes equipos tienen m√∫ltiples combinaciones v√°lidas. Selecciona la distribuci√≥n correcta:</p>
    <div id="manualAssignments"></div>
    <div style="margin-top: 20px; text-align: right;">
      <button id="confirmManualAssignments" class="button">Confirmar Asignaciones</button>
      <button id="cancelManualAssignments" class="button" style="background-color: #6c757d; margin-left: 10px;">Cancelar</button>
    </div>
  `;
  
  const assignmentsDiv = modal.querySelector('#manualAssignments');
  
  // Crear selectores para cada equipo que requiere asignaci√≥n manual
  manualAssignments.forEach((assignment, teamIndex) => {
    const { baseTeam, subteams, candidates, validCombinations, scores } = assignment;
    
    const teamDiv = document.createElement('div');
    teamDiv.style.cssText = 'margin: 20px 0; padding: 20px; border: 2px solid #007bff; border-radius: 8px; background-color: #f8f9fa;';
    
    let combinationsHtml = '';
    validCombinations.forEach((combo, comboIndex) => {
      const team1Players = combo.team1.map(p => `${p.name}(${p.points})`).join(' + ');
      const team2Players = combo.team2.map(p => `${p.name}(${p.points})`).join(' + ');
      
      combinationsHtml += `
        <div style="margin: 10px 0;">
          <input type="radio" id="combo_${teamIndex}_${comboIndex}" name="team_${teamIndex}" value="${comboIndex}">
          <label for="combo_${teamIndex}_${comboIndex}" style="margin-left: 8px;">
            <strong>${subteams[0]}</strong>: ${team1Players} = ${scores.team1} | 
            <strong>${subteams[1]}</strong>: ${team2Players} = ${scores.team2}
          </label>
        </div>
      `;
    });
    
    teamDiv.innerHTML = `
      <h4 style="margin-top: 0; color: #007bff;">${baseTeam}</h4>
      <div style="margin-bottom: 15px; font-size: 14px; color: #666;">
        Jugadores: ${candidates.map(p => `${p.name}(${p.points})`).join(', ')}
      </div>
      <div style="margin-bottom: 10px; font-weight: bold;">Selecciona la distribuci√≥n correcta:</div>
      ${combinationsHtml}
    `;
    
    assignmentsDiv.appendChild(teamDiv);
  });
  
  container.appendChild(modal);
  document.body.appendChild(container);
  
  // Configurar eventos
  modal.querySelector('#confirmManualAssignments').onclick = () => {
    let allAssigned = true;
    
    manualAssignments.forEach((assignment, teamIndex) => {
      const selectedRadio = document.querySelector(`input[name="team_${teamIndex}"]:checked`);
      if (selectedRadio) {
        const comboIndex = parseInt(selectedRadio.value);
        const selectedCombo = assignment.validCombinations[comboIndex];
        
        // Asignar jugadores seg√∫n la combinaci√≥n seleccionada
        selectedCombo.team1.forEach(player => {
          player.team = assignment.subteams[0];
        });
        selectedCombo.team2.forEach(player => {
          player.team = assignment.subteams[1];
        });
        
        console.log(`Asignado manualmente: ${assignment.baseTeam}`);
      } else {
        allAssigned = false;
      }
    });
    
    if (allAssigned) {
      document.body.removeChild(container);
      showSuccess('Todas las asignaciones manuales completadas correctamente');
      callback(); // Resolver la promesa
    } else {
      showError('Por favor, selecciona una opci√≥n para todos los equipos');
    }
  };
  
  modal.querySelector('#cancelManualAssignments').onclick = () => {
    document.body.removeChild(container);
    showError('Procesamiento cancelado por el usuario');
    callback(); // Resolver la promesa aunque se cancele
  };
}
  
async function downloadExcel_MASTER(){
  if (!processedData || processedData.length === 0) return showError('No hay datos procesados de M√°ster');
  
  const wb = new ExcelJS.Workbook();
  wb.created = new Date();
  
  const ws = wb.addWorksheet('Master Equipos', { views:[{ state:'normal', showGridLines:false }] });
  buildMasterSheet(ws, processedData[0]);
  
  const uint8 = await wb.xlsx.writeBuffer();
  saveAs(new Blob([uint8], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}), `Master_Equipos.xlsx`);
  showSuccess('Excel M√°ster generado correctamente.');
}

function buildMasterSheet(ws, data) {
  // Reutilizar la misma l√≥gica que Copa pero con m√°ximo 2 jugadores por equipo
  buildCopaSheet(ws, data);
}

/* ================================================================
   ====================== BLOQUE RELEVOS ==========================
   ================================================================ */

function processJornada_RELEVOS(){
  const files = document.getElementById('fileInputJornada').files;
  if (!files || files.length !== 3) {
    return showError('Para el Torneo Relevos debes subir exactamente 3 archivos (.txt) correspondientes a las 3 tem√°ticas');
  }
  
  // Pedir las 3 tem√°ticas al usuario
  const theme1 = prompt('Nombre de la 1¬™ tem√°tica:');
  if (!theme1) return showError('Debes introducir el nombre de la 1¬™ tem√°tica');
  
  const theme2 = prompt('Nombre de la 2¬™ tem√°tica:');
  if (!theme2) return showError('Debes introducir el nombre de la 2¬™ tem√°tica');
  
  const theme3 = prompt('Nombre de la 3¬™ tem√°tica:');
  if (!theme3) return showError('Debes introducir el nombre de la 3¬™ tem√°tica');
  
  const themes = [theme1, theme2, theme3];
  
  processedData = { isRelevos: true, themes: themes, logs: [] };
  let processed = 0;
  
  Array.from(files).forEach(async (file, index) => {
    try {
      const text = await file.text();
      const logData = parseRelevosLog(text, themes[index], index + 1);
      processedData.logs[index] = logData;
      processed++;
      
      if (processed === files.length) {
        // Procesar datos del torneo
        const relevosResults = processRelevosResults(processedData.logs, themes);
        processedData.relevosResults = relevosResults;
        
        const res = document.getElementById('results');
        res.innerHTML = `<div class="success">Torneo Relevos: 3 archivos procesados. Pulsa "Descargar Excel".</div>`;
        res.style.display = 'block';
        document.getElementById('downloadSection').style.display='block';
        document.getElementById('downloadBtn').disabled = false;
        currentProcess='jornada';
      }
    } catch(err) { 
      showError(`Error procesando ${file.name}: ${err.message}`); 
    }
  });
}

function parseRelevosLog(content, theme, logNumber) {
  const lines = content.split('\n').map(l => l.trim()).filter(Boolean);
  const teamStart = lines.findIndex(l => l.toUpperCase().includes('CLASIFICACION EQUIPOS'));
  const playerStart = lines.findIndex(l => l.toUpperCase().includes('CLASIFICACION INDIVIDUAL'));
  
  if (teamStart === -1 || playerStart === -1) {
    throw new Error('Secciones no encontradas en el log');
  }
  
  // Extraer equipos con puntuaciones
  const teams = {};
  for (let i = teamStart + 1; i < playerStart; i++) {
    const m = /^(.*?)\s+(-?\d+)\s*$/.exec(lines[i]);
    if (!m) continue;
    const teamName = m[1].trim();
    const points = parseInt(m[2], 10);
    teams[teamName] = points;
  }
  
  // Extraer TODOS los jugadores (con y sin puntos)
  const allPlayers = [];
  for (let i = playerStart + 1; i < lines.length; i++) {
    const line = lines[i];
    if (!line) continue;
    
    const parts = line.split(/\s+/);
    if (parts.length < 2) continue;
    
    const name = parts[0].toUpperCase();
    const isAbsent = line.toUpperCase().includes('NO ESTUVO PRESENTE');
    const points = isAbsent ? 0 : parseInt(parts[1], 10);
    const aces = isAbsent ? 0 : parseInt((line.match(/Aces:\s*(\d+)/i) || [0,0])[1], 10);
    const scratches = isAbsent ? 0 : parseInt((line.match(/Scr:\s*(\d+)/i) || [0,0])[1], 10);
    const palos = isAbsent ? 0 : parseInt((line.match(/Palos:\s*(\d+)/i) || [0,0])[1], 10);
    
    allPlayers.push({
      name: name,
      points: points,
      aces: aces,
      scratches: scratches,
      palos: palos,
      participated: points > 0 || aces > 0 || scratches > 0 || palos > 0
    });
  }
  
  // Asignar equipos por orden alfab√©tico
  const teamsAlpha = Object.keys(teams).sort((a, b) => a.localeCompare(b, 'es', { sensitivity: 'base' }));
  
  let currentTeamIndex = 0;
  let prevNick = '';
  
  allPlayers.forEach((player, index) => {
    // Detectar salto alfab√©tico = cambio de equipo
    if (index > 0 && player.name.localeCompare(prevNick, 'es', { sensitivity: 'base' }) < 0) {
      currentTeamIndex++;
      if (currentTeamIndex >= teamsAlpha.length) {
        currentTeamIndex = teamsAlpha.length - 1;
      }
    }
    
    player.team = teamsAlpha[currentTeamIndex] || 'SinEquipo';
    prevNick = player.name;
  });
  
  // Filtrar solo los que participaron para el resultado final
  const participatingPlayers = {};
  allPlayers.forEach(player => {
    if (player.participated) {
      participatingPlayers[player.name] = {
        name: player.name,
        team: player.team,
        points: player.points,
        aces: player.aces,
        scratches: player.scratches,
        palos: player.palos
      };
    }
  });
  
  return {
    theme: theme,
    logNumber: logNumber,
    teams: teams,
    players: participatingPlayers
  };
}

function processRelevosResults(logs, themes) {
  const allTeams = {};
  
  // Obtener lista de todos los equipos √∫nicos
  logs.forEach(log => {
    Object.keys(log.teams).forEach(teamName => {
      if (!allTeams[teamName]) {
        allTeams[teamName] = {
          name: teamName,
          totalPoints: 0,
          totalScratches: 0,
          totalPalos: 0,
          totalAces: 0,
          thematics: {},
          players: {} // {playerName: {thematic1: {...}, thematic2: {...}}}
        };
      }
    });
  });
  
  // Acumular estad√≠sticas por equipo y por jugador
  logs.forEach(log => {
    const themeName = `thematic${log.logNumber}`;
    
    Object.entries(log.teams).forEach(([teamName, teamPoints]) => {
      const team = allTeams[teamName];
      
      // Acumular totales del equipo
      team.totalPoints += teamPoints;
      
      // Guardar datos de esta tem√°tica para el equipo
      team.thematics[themeName] = {
        theme: log.theme,
        points: teamPoints,
        scratches: 0,
        palos: 0,
        aces: 0,
        players: []
      };
    });
    
    // Asignar jugadores a equipos (ya vienen con el equipo asignado desde parseRelevosLog)
    Object.entries(log.players).forEach(([playerName, playerData]) => {
      const teamName = playerData.team;
      const team = allTeams[teamName];
      
      // Acumular estad√≠sticas del equipo en esta tem√°tica
      team.thematics[themeName].scratches += playerData.scratches;
      team.thematics[themeName].palos += playerData.palos;
      team.thematics[themeName].aces += playerData.aces;
      team.thematics[themeName].players.push({
        name: playerName,
        points: playerData.points,
        scratches: playerData.scratches,
        palos: playerData.palos,
        aces: playerData.aces
      });
      
      // Acumular totales generales del equipo
      team.totalScratches += playerData.scratches;
      team.totalPalos += playerData.palos;
      team.totalAces += playerData.aces;
      
      // Guardar informaci√≥n del jugador
      if (!team.players[playerName]) {
        team.players[playerName] = {};
      }
      team.players[playerName][themeName] = {
        theme: log.theme,
        points: playerData.points,
        scratches: playerData.scratches,
        palos: playerData.palos,
        aces: playerData.aces
      };
      
      prevPlayerName = playerName;
    });
  });
  
  // Ordenar equipos por puntos totales
  const sortedTeams = Object.values(allTeams).sort((a, b) => b.totalPoints - a.totalPoints);
  
  return {
    teams: sortedTeams,
    themes: themes
  };
}

async function downloadExcel_RELEVOS(){
  if (!processedData || !processedData.isRelevos) {
    return showError('No hay datos procesados del Torneo Relevos');
  }
  
  const wb = new ExcelJS.Workbook();
  wb.created = new Date();
  
  const ws = wb.addWorksheet('Torneo Relevos', { views:[{ state:'normal', showGridLines:false }] });
  buildRelevosSheet(ws, processedData.relevosResults);
  
  const uint8 = await wb.xlsx.writeBuffer();
  saveAs(new Blob([uint8], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}), `Torneo_Relevos.xlsx`);
  showSuccess('Excel Torneo Relevos generado correctamente.');
}

function buildRelevosSheet(ws, results) {
  const themeW = widthFromPx(118);
  const numW = widthFromPx(40);
  const posW = widthFromPx(35);
  const nameW = widthFromPx(85);  // Reducido de 140 a 85

  // Colores
  const whiteARGB = 'FFFFFFFF';
  const blackARGB = 'FF000000';
  const beigeARGB = 'FFF5E6D3';

  ws.views = [{ state: 'normal', showGridLines: false }];

  // ===== ORDENACI√ìN PREVIA =====
  const teamSorter = (a, b) =>
    (b.totalPoints   - a.totalPoints)   ||
    (b.totalScratches- a.totalScratches)||
    (b.totalAces     - a.totalAces)     ||
    (b.totalPalos    - a.totalPalos);

  const playerSorter = (a, b) =>
    (b.points    - a.points)    ||
    (b.scratches - a.scratches) ||
    (b.aces      - a.aces)      ||
    (b.palos     - a.palos);

  // Ordena equipos
  results.teams.sort(teamSorter);
  // Ordena jugadores dentro de cada tem√°tica de cada equipo
  results.teams.forEach(team => {
    for (let i = 1; i <= 3; i++) {
      const td = team.thematics?.[`thematic${i}`];
      if (td?.players?.length) td.players.sort(playerSorter);
    }
  });

  // Cabeceras principales (solo una fila) - SIN "Equipo" ni "TEMA"
  const headers = ['Pos', '', 'T', 's', 'p', 'a'];
  results.themes.forEach(theme => {
    headers.push('', 'T', 's', 'p', 'a');
  });

  headers.forEach((header, col) => {
    const cell = ws.getCell(1, col + 1);
    cell.value = header;
    cell.font = { bold: true, color: { argb: whiteARGB } };
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: blackARGB } };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
  });

  // Escribir nombres de tem√°ticas en la fila 1 (sin uppercasing), alineados a la **derecha**
  results.themes.forEach((themeName, themeIndex) => {
    const baseCol = 7 + (themeIndex * 5);
    const themeCell = ws.getCell(1, baseCol);
    themeCell.value = themeName; // ‚Üê tal cual lo introduce el usuario
    themeCell.font = { bold: true, color: { argb: whiteARGB } };
    themeCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: blackARGB } };
    themeCell.alignment = { horizontal: 'right', vertical: 'middle' }; // ‚Üê derecha
  });

  let currentRow = 2;

  results.teams.forEach((team, teamIndex) => {
    const position = teamIndex + 1;
    const baseTeamName = team.name.replace(/\s+(I|II)$/, '');
    const teamColors = COLORES_EQUIPOS[baseTeamName] || { bg: '#CCCCCC', fg: '#000000' };

    const blockFill = (teamIndex % 2 === 1) ? { type: 'pattern', pattern: 'solid', fgColor: { argb: beigeARGB } } : null;
    const blackFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: blackARGB } };

    // === FILAS REALES: suma de jugadores de cada tem√°tica (sin separadores) ===
    const len1 = team.thematics?.thematic1?.players?.length || 0;
    const len2 = team.thematics?.thematic2?.players?.length || 0;
    const len3 = team.thematics?.thematic3?.players?.length || 0;
    const rowsForPlayers = len1 + len2 + len3;

    // 1 = fila de cabecera del equipo
    const totalRowsForTeam = 1 + rowsForPlayers;

    // FILA DEL EQUIPO (fondo negro)
    const posCell = ws.getCell(currentRow, 1);
    posCell.value = position;
    posCell.font = { bold: true, color: { argb: whiteARGB } };
    posCell.fill = blackFill;
    posCell.alignment = { horizontal: 'center', vertical: 'middle' };

    const teamCell = ws.getCell(currentRow, 2);
    teamCell.value = team.name;
    teamCell.font = { bold: true, color: { argb: teamColors.fg.replace('#','FF') } };
    teamCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: teamColors.bg.replace('#','FF') } };
    teamCell.alignment = { horizontal: 'center', vertical: 'middle' };

    // Totales generales
    const totals = [team.totalPoints, team.totalScratches, team.totalPalos, team.totalAces];
    totals.forEach((val, i) => {
      const cell = ws.getCell(currentRow, 3 + i);
      cell.value = val;
      cell.font = { bold: true, color: { argb: whiteARGB } };
      cell.fill = blackFill;
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
    });

    // Subtotales de tem√°ticas (sin nombre de tem√°tica, ya est√° en fila 1)
    for (let thematicNum = 1; thematicNum <= 3; thematicNum++) {
      const baseCol = 7 + ((thematicNum - 1) * 5);
      const thematicData = team.thematics[`thematic${thematicNum}`];

      // Celda vac√≠a donde antes iba el nombre de la tem√°tica
      const themeCell = ws.getCell(currentRow, baseCol);
      themeCell.value = '';
      themeCell.font = { bold: true, color: { argb: whiteARGB } };
      themeCell.fill = blackFill;
      themeCell.alignment = { horizontal: 'center', vertical: 'middle' };

      if (thematicData) {
        const thematicTotals = [
          thematicData.points,
          thematicData.scratches,
          thematicData.palos,
          thematicData.aces
        ];

        thematicTotals.forEach((val, i) => {
          const cell = ws.getCell(currentRow, baseCol + 1 + i);
          cell.value = val;
          cell.font = { bold: true, color: { argb: whiteARGB } };
          cell.fill = blackFill;
          cell.alignment = { horizontal: 'center', vertical: 'middle' };
        });
      } else {
        for (let i = 0; i < 4; i++) {
          const cell = ws.getCell(currentRow, baseCol + 1 + i);
          cell.fill = blackFill;
        }
      }
    }

    // Rellenar fondo del bloque de jugadores (exactamente las filas reales pintadas)
    for (let r = 1; r <= rowsForPlayers; r++) {
      for (let c = 1; c <= 6 + (3 * 5); c++) {
        const cell = ws.getCell(currentRow + r, c);
        if (blockFill) cell.fill = blockFill;
      }
    }

    // Colocar jugadores SIN saltos extra entre tem√°ticas
    let playerRow = currentRow + 1;  // primera fila tras la cabecera del equipo

    for (let thematicNum = 1; thematicNum <= 3; thematicNum++) {
      const baseCol = 7 + ((thematicNum - 1) * 5);
      const thematicData = team.thematics[`thematic${thematicNum}`];

      if (thematicData && thematicData.players.length > 0) {
        // (Ya est√°n ordenados por playerSorter arriba)
        thematicData.players.forEach((player) => {
          // Nombre (alineado a la DERECHA, como pides)
          const playerNameCell = ws.getCell(playerRow, baseCol);
          playerNameCell.value = player.name;
          playerNameCell.alignment = { horizontal: 'right', vertical: 'middle' }; // ‚Üê derecha
          if (blockFill) playerNameCell.fill = blockFill;

          // T, s, p, a
          const playerStats = [player.points, player.scratches || '', player.palos || '', player.aces || ''];
          playerStats.forEach((val, i) => {
            const cell = ws.getCell(playerRow, baseCol + 1 + i);
            cell.value = val;
            cell.alignment = { horizontal: 'center', vertical: 'middle' };
            if (blockFill) cell.fill = blockFill;
          });

          playerRow++; // avanzar UNA fila por jugador
        });
      }
    }

    // Avance al siguiente equipo: 1 (cabecera) + filas reales de jugadores
    currentRow += totalRowsForTeam;
  });

  // Configurar anchos
  ws.getColumn(1).width = posW;
  ws.getColumn(2).width = nameW;  // 85 p√≠xeles
  ws.getColumn(3).width = numW;
  ws.getColumn(4).width = numW;
  ws.getColumn(5).width = numW;
  ws.getColumn(6).width = numW;

  for (let i = 0; i < 3; i++) {
    const baseCol = 7 + (i * 5);
    ws.getColumn(baseCol).width = themeW;     // TEMA (118px)
    ws.getColumn(baseCol + 1).width = numW;   // T
    ws.getColumn(baseCol + 2).width = numW;   // s
    ws.getColumn(baseCol + 3).width = numW;   // p
    ws.getColumn(baseCol + 4).width = numW;   // a
  }
}



/* ==================== FIN BLOQUE RELEVOS ===================== */

/* ===================== FIN BLOQUE MASTER ===================== */
  
/* ===================== FIN BLOQUE COPA ===================== */

/* ===================== FIN BLOQUE GP ===================== */
</script>
</body>
</html>
