<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Procesador de Logs de Trivial IRC ‚Äî V14.2</title>
  <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; }
    .container { background-color: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    h1 { color: #333; text-align: center; margin-bottom: 30px; }
    .upload-section { border: 2px dashed #ddd; padding: 40px; text-align: center; margin-bottom: 30px; border-radius: 8px; background-color: #fafafa; }
    .upload-section:hover { border-color: #007bff; background-color: #f0f8ff; }
    input[type="file"] { margin: 20px 0; }
    .button { background-color: #007bff; color: white; padding: 12px 25px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; margin: 10px; }
    .button:hover { background-color: #0056b3; }
    .button:disabled { background-color: #ccc; cursor: not-allowed; }
    .results { margin-top: 30px; }
    .team-section { margin-bottom: 30px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; }
    .team-header { padding: 15px; font-weight: bold; font-size: 18px; text-align: center; }
    .stats-table { width: 100%; border-collapse: collapse; }
    .stats-table th, .stats-table td { padding: 8px 12px; text-align: center; border: 1px solid #ddd; }
    .stats-table th { background-color: #f8f9fa; font-weight: bold; }
    .player-row { background-color: white; }
    .error { color: #dc3545; background-color: #f8d7da; padding: 15px; border-radius: 5px; margin: 20px 0; }
    .success { color: #155724; background-color: #d4edda; padding: 15px; border-radius: 5px; margin: 20px 0; }
    .log-info { background-color: #e9ecef; padding: 15px; border-radius: 5px; margin: 20px 0; }
    .competition-select { text-align: center; margin-bottom: 30px; }
    .competition-select label { font-weight: bold; margin-right: 10px; }
    select { padding: 6px 10px; font-size: 14px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéØ Procesador de Logs de Trivial IRC</h1>

    <!-- SELECCI√ìN DE COMPETICI√ìN -->
    <div class="competition-select">
      <label for="competitionSelect">Tipo de competici√≥n:</label>
      <select id="competitionSelect">
        <option value="liga" selected>Liga</option>
        <option value="gp">GP</option>
        <option value="copa">Copa</option>
        <option value="relevos">Torneo Relevos</option>
        <option value="master">M√°ster por Equipos</option>
        <option value="posiciones">Torneo Posiciones</option>
      </select>
    </div>

    <!-- PROCESO 1: Estad√≠sticas de la Jornada -->
    <div class="upload-section">
      <h3>üìä Estad√≠sticas de la Jornada</h3>
      <p>Sube los logs (.txt) de las partidas de una jornada espec√≠fica</p>
      <input type="file" id="fileInputJornada" accept=".txt" multiple />
      <br />
      <button class="button" onclick="processJornada()" id="processJornadaBtn" disabled>Procesar Jornada</button>
    </div>

    <!-- PROCESO 2: Totales y Medias (Liga) -->
    <div class="upload-section" style="border-color: #28a745; background-color: #f8fff9;">
      <h3>üèÜ Totales y Medias Liga</h3>
      <p>Sube los Excels (.xlsx) generados de cada jornada para obtener totales acumulados</p>
      <input type="file" id="fileInputTotales" accept=".xlsx" multiple />
      <br />
      <button class="button" onclick="processTotales()" id="processTotalesBtn" disabled style="background-color: #28a745;">Generar Totales Liga</button>
    </div>

    <div id="results" class="results" style="display: none;"></div>

    <div id="downloadSection" style="display: none; text-align: center; margin-top: 30px;">
      <button class="button" onclick="downloadExcel()" id="downloadBtn">üì• Descargar Excel</button>
    </div>
  </div>

  <script>
    /*****************
     * ESTADO / UI
     *****************/
    let competitionType = 'liga';
    let processedData = [];
    let fileNames = [];
    let currentProcess = ''; // 'jornada' | 'totales'

    document.addEventListener('DOMContentLoaded', ()=>{
      const inJ = document.getElementById('fileInputJornada');
      const inT = document.getElementById('fileInputTotales');
      const bJ  = document.getElementById('processJornadaBtn');
      const bT  = document.getElementById('processTotalesBtn');
      const sel = document.getElementById('competitionSelect');
      if (inJ) inJ.addEventListener('change', ()=>{ bJ.disabled = !(inJ.files && inJ.files.length); fileNames = inJ.files? Array.from(inJ.files).map(f=>f.name):[]; });
      if (inT) inT.addEventListener('change', ()=>{ bT.disabled = !(inT.files && inT.files.length); fileNames = inT.files? Array.from(inT.files).map(f=>f.name):[]; });
      if (sel) sel.addEventListener('change', ()=>{ competitionType = sel.value; });
    });

    function showError(msg){ const res=document.getElementById('results'); res.innerHTML=`<div class="error">${msg}</div>`; res.style.display='block'; }
    function showSuccess(msg){ const res=document.getElementById('results'); res.innerHTML=`<div class="success">${msg}</div>`; res.style.display='block'; }

    /*****************
     * CONSTANTES / UTILIDADES
     *****************/
    const COLORES_EQUIPOS = {
      "FOGUETES": {"bg": "#009F9F", "fg": "#00FF00"},
      "ATIPIK@S": {"bg": "#00FF00", "fg": "#0000FF"},
      "REPESCA@S": {"bg": "#C000C0", "fg": "#00FF00"},
      "DARKSHADOWS": {"bg": "#000000", "fg": "#808080"},
      "TELERINEZ": {"bg": "#000000", "fg": "#00FFFF"},
      "KAMIKAZES": {"bg": "#000000", "fg": "#FF0000"},
      "HARDBE@TS": {"bg": "#000000", "fg": "#FFFF00"},
      "LIDERES": {"bg": "#C000C0", "fg": "#FFFFFF"}
    };

    const PX_PER_CHAR = 7; // aproximaci√≥n ExcelJS: width ‚âà px/7
    const w = (px) => +(px / PX_PER_CHAR).toFixed(2);

    function addFraming(ws, padWidth){
      const width = padWidth || ws.columns?.[0]?.width || w(27);
      ws.columns = [...ws.columns, { width }];
      // fila superior e inferior finas
      ws.spliceRows(1, 0, []);
      try{ ws.getRow(1).height = 7.5; }catch{}
      ws.addRow([]);
      try{ ws.getRow(ws.lastRow.number).height = 7.5; }catch{}
    }

    // Normalizaci√≥n / orden de nicks (s√≠mbolos antes que 'A')
    function normalizeNick(nick){
      return String(nick||'').trim().toUpperCase()
        .normalize('NFD')
        .replace(/\p{Diacritic}+/gu,'');
    }
    function nickKey(nick){
      const s = normalizeNick(nick);
      const first = s.charAt(0);
      const isLetter = /^[A-Z√ë]$/.test(first);
      return (isLetter ? '1' : '0') + s;
    }
    function cmpNick(a,b){
      const A = nickKey(a), B = nickKey(b);
      return A.localeCompare(B,'es',{sensitivity:'base',numeric:true});
    }

    // Excel helpers (leer texto/num desde Excel)
    function xlsToString(v){ if (v == null) return ''; if (typeof v === 'string') return v; if (typeof v === 'number') return String(v); if (v.richText) return v.richText.map(t=>t.text).join(''); if (v.text) return v.text; if (v.result != null) return xlsToString(v.result); return String(v); }
    function norm(v){ return xlsToString(v).trim().toUpperCase(); }
    function numOrNull(v){ const s = xlsToString(v).replace(',','.').trim(); if(!s) return null; const n=Number(s); return Number.isFinite(n)?n:null; }

    /*****************
     * PARSER LIGA (logs .txt)
     *****************/
    function parseLogFileSymbols(content){
      const lines = content.split('\n').map(l=>l.trim()).filter(Boolean);
      const teamStart = lines.findIndex(l=>/CLASIFICACION\s+EQUIPOS/i.test(l));
      const playerStart = lines.findIndex(l=>/CLASIFICACION\s+INDIVIDUAL/i.test(l));
      if (teamStart === -1 || playerStart === -1) throw new Error('Secciones no encontradas');

      const teams = {}, teamOrder = [];
      for (let i=teamStart+1; i<playerStart; i++){
        const m = /^(.*?)\s+(-?\d+)\s*$/.exec(lines[i]); if(!m) continue;
        const team = m[1].trim(); const points = parseInt(m[2],10);
        teams[team]=points; teamOrder.push(team);
      }

      const players = [];
      for (let i=playerStart+1; i<lines.length; i++){
        const line = lines[i]; if(!line) continue;
        const parts = line.split(/\s+/); if (parts.length < 2) continue;
        const name = parts[0]; const points = parseInt(parts[1], 10);
        const absent = /NO\s+ESTUVO\s+PRESENTE/i.test(line);
        players.push({
          name: name.toUpperCase(),
          points: absent ? null : points,
          aces: parseInt((line.match(/Aces:\s*(\d+)/i) || [0,0])[1],10),
          scratches: parseInt((line.match(/Scr:\s*(\d+)/i) || [0,0])[1],10),
          palos: parseInt((line.match(/Palos:\s*(\d+)/i) || [0,0])[1],10),
          absent
        });
      }

      const teamsAlpha = Object.keys(teams).sort((a,b)=>cmpNick(a,b));
      if (players.length){
        players[0].team = teamsAlpha[0] || 'SinEquipo';
        let prev = players[0].name, switched=false;
        for (let i=1;i<players.length;i++){
          const curr = players[i];
          if (!switched && cmpNick(curr.name, prev) < 0) switched = true;
          curr.team = switched ? (teamsAlpha[1] || 'SinEquipo') : (teamsAlpha[0] || 'SinEquipo');
          prev = curr.name;
        }
      }

      return { teams, teamOrder, players };
    }

    /*****************
     * PARSER GP (logs .txt)
     *****************/
    function parseGPLog(text){
      const lines = String(text).split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const idxCE = lines.findIndex(l => /^CLASIFICACION\s+EQUIPOS$/i.test(l));
      const idxCI = lines.findIndex(l => /^CLASIFICACION\s+INDIVIDUAL$/i.test(l));
      if (idxCE === -1 || idxCI === -1) throw new Error('Secciones no encontradas');

      // Nombre de grupo desde la l√≠nea siguiente de CE (si existe ‚ÄúGRUPO A   999‚Äù)
      let groupName = 'GRUPO';
      const mm = /^(GRUPO\s+[A-Z√Å√â√ç√ì√ö√ë]+)\s+(-?\d+)/i.exec(lines[idxCE + 1] || '');
      if (mm) groupName = mm[1].toUpperCase();

      const rePresent = /^(\S[\S ]*?)(?:\s{2,}|\t+)(-?\d+)\s+.*?Aces:\s*(\d+)\s+Scr:\s*(\d+)\s+Palos:\s*(\d+)/i;
      const reAbsent  = /^(\S[\S ]*?)(?:\s{2,}|\t+)0\s+NO\s+ESTUVO\s+PRESENTE/i;

      const players = [];
      for (let i = idxCI + 1; i < lines.length; i++) {
        const L = lines[i];
        let m = rePresent.exec(L);
        if (m) {
          players.push({
            name: m[1].trim().toUpperCase(),
            pts: parseInt(m[2],10)||0,
            aces: parseInt(m[3],10)||0,
            scr:  parseInt(m[4],10)||0,
            pos:  parseInt(m[5],10)||0,
            present: true
          });
          continue;
        }
        m = reAbsent.exec(L);
        if (m) {
          players.push({
            name: m[1].trim().toUpperCase(),
            pts: 0, aces: 0, scr: 0, pos: 0, present: false
          });
        }
      }
      if (!players.length) throw new Error('No se detectaron jugadores');

      // GPP por posiciones con empates (media)
      const present = players.filter(p => p.present).sort((a,b)=> b.pts - a.pts);
      const gppTable = [20,17,15,13,11,10,9,8,7,6,5,4,3,2,1]; // 1..15
      const gppAt = (pos)=> gppTable[pos-1] || 0;
      const avgGPP = (from, to)=>{
        let sum=0,n=0; for(let i=from;i<=to;i++){ sum+=gppAt(i); n++; } return +(sum/n).toFixed(2);
      };

      let i=0,pos=1;
      while (i<present.length){
        let j=i+1; while (j<present.length && present[j].pts===present[i].pts) j++;
        const start=pos, end=pos+(j-i)-1, g=avgGPP(start,end);
        for (let k=i;k<j;k++){ present[k].gpp=g; present[k].rank=start; }
        pos=end+1; i=j;
      }
      const absent = players.filter(p=>!p.present).map(p=>({...p, gpp:0, rank:null}));

      return { group: groupName, players: [...present, ...absent] };
    }

    /*****************
     * UI PREVIEW
     *****************/
    function displayResults(allData){
      const resultsDiv = document.getElementById('results'); resultsDiv.innerHTML = '';
      const info = document.createElement('div'); info.className = 'log-info';
      let totalTeams = 0, totalPlayers = 0;
      allData.forEach(d => { totalTeams += d.teamOrder.length; totalPlayers += d.players.length; });
      info.innerHTML = `<h3>üìä Informaci√≥n de los Logs</h3>
        <p><strong>Partidas procesadas:</strong> ${allData.length}</p>
        <p><strong>Total de equipos:</strong> ${totalTeams}</p>
        <p><strong>Total de jugadores:</strong> ${totalPlayers}</p>`;
      resultsDiv.appendChild(info); resultsDiv.style.display='block';
    }

    function displayGPResults(groups){
      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = `
        <div class="log-info">
          <h3>üèÅ GP ‚Äî Grupos detectados</h3>
          <p><strong>Grupos:</strong> ${groups.length}</p>
          <p><em>Pulsa "Descargar Excel" para generar los cuadros.</em></p>
        </div>`;
      resultsDiv.style.display = 'block';
    }

    /*****************
     * PROCESOS (carga)
     *****************/
    function processJornada(){
      const files = document.getElementById('fileInputJornada').files;
      if (!files || files.length === 0) return showError('Selecciona al menos un archivo .txt');
      processedData = []; fileNames = Array.from(files).map(f=>f.name); currentProcess = 'jornada';
      let done=0;
      Array.from(files).forEach((file, index)=>{
        const reader = new FileReader();
        reader.onload = (e)=>{
          try{
            const content = e.target.result;
            if (competitionType === 'gp'){
              processedData[index] = parseGPLog(content);
            } else {
              processedData[index] = parseLogFileSymbols(content);
            }
            done++;
            if (done === files.length){
              if (competitionType === 'gp') displayGPResults(processedData);
              else displayResults(processedData);
              document.getElementById('downloadSection').style.display='block';
              showSuccess(`${files.length} archivo${files.length>1?'s':''} procesado${files.length>1?'s':''} correctamente`);
            }
          }catch(err){ showError(`Error al procesar ${file.name}: ${err.message}`); }
        };
        reader.readAsText(file);
      });
    }

    async function processTotales(){
      const files = document.getElementById('fileInputTotales').files;
      if (!files || files.length === 0) return showError("Selecciona al menos un archivo Excel");
      try {
        processedData = []; currentProcess = 'totales';
        for (let i=0;i<files.length;i++){
          const buffer = await files[i].arrayBuffer();
          const wb = new ExcelJS.Workbook();
          await wb.xlsx.load(buffer);
          const ws = wb.getWorksheet("Estad√≠sticas") || wb.getWorksheet("Estadisticas") || wb.worksheets.find(s => (s.name||'').toLowerCase().includes('estadist'));
          if (!ws) { showError(`El archivo ${files[i].name} no tiene hoja "Estad√≠sticas"`); return; }
          const matches = extractDataFromExcel(ws);
          processedData.push(...matches);
        }
        if (!processedData.length){ showError("No se localizaron partidas en 'Estad√≠sticas'."); return; }
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = `<div class="log-info"><h3>üèÜ Totales Liga</h3><p><strong>Partidas totales:</strong> ${processedData.length}</p><p><em>Pulsa ‚ÄúDescargar Excel‚Äù.</em></p></div>`;
        resultsDiv.style.display = 'block';
        document.getElementById('downloadSection').style.display='block';
      } catch(e){ showError('Error procesando archivos Excel: '+e.message); }
    }

    /*****************
     * DESCARGA EXCEL
     *****************/
    async function downloadExcel(){
      if (!processedData || !processedData.length) return showError('No hay datos procesados');
      try{
        const wb = new ExcelJS.Workbook();

        if (currentProcess === 'jornada'){
          if (competitionType === 'gp'){
            const ws = wb.addWorksheet('GP', { views: [{ showGridLines: false }] });
            buildGPSheet(ws, processedData);
          } else {
            const ws = wb.addWorksheet('Estad√≠sticas', { views: [{ showGridLines: false }] });
            buildLigaJornadaSheet(ws, processedData);
          }
        } else {
          // Totales y Medias (Liga)
          const ws1 = wb.addWorksheet('Totales', { views: [{ showGridLines: false }] });
          generateTotalsSheet(ws1);
          const ws2 = wb.addWorksheet('Totales2', { views: [{ showGridLines: false }] });
          generateTotals2Sheet(ws2); // versi√≥n ampliada de fuentes
        }

        const buffer = await wb.xlsx.writeBuffer();
        const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const url = URL.createObjectURL(blob);
        const a=document.createElement('a'); a.href=url;

        if (currentProcess === 'jornada') {
          const base = (fileNames||[]).map(n=>n.replace(/\.txt$/,'')).join('_') || 'Jornada';
          a.download = `${competitionType==='gp'?'GP':'Jornada'}_${base}.xlsx`;
        } else {
          a.download = `Totales_Liga_${new Date().toISOString().slice(0,10)}.xlsx`;
        }
        a.click(); URL.revokeObjectURL(url);
        showSuccess('Excel generado correctamente');
      }catch(err){ console.error(err); showError('Error generando Excel: '+err.message); }
    }

    /*****************
     * CONSTRUCCI√ìN HOJAS ‚Äî LIGA (Jornada)
     *****************/
    function buildLigaJornadaSheet(ws, matches){
      const NAME_W = w(121);
      let currentRow = 1;

      matches.forEach(matchData => {
        const teams = matchData.teamOrder.map(teamName => ({
          name: teamName,
          points: matchData.teams[teamName],
          players: matchData.players
            .filter(p=>p.team===teamName)
            .sort((a,b)=>{
              if (a.absent && !b.absent) return 1;
              if (!a.absent && b.absent) return -1;
              return (b.points||0)-(a.points||0);
            }),
          colors: COLORES_EQUIPOS[teamName] || { bg:'#CCCCCC', fg:'#000000' }
        }));

        const teamTotals = teams.map(t=>{
          const tot={scratches:0, palos:0, aces:0};
          t.players.forEach(p=>{ if(!p.absent){ tot.scratches+=p.scratches; tot.palos+=p.palos; tot.aces+=p.aces; }});
          return tot;
        });

        // Fila cabecera (sin ‚ÄúNOMBRE‚Äù, solo nombres m√©tricas)
        const hdr = [''];
        teams.forEach((t,i)=>{ hdr.push(''); hdr.push('Puntos'); hdr.push('Scratches'); hdr.push('Palos'); hdr.push('Aces'); if(i<teams.length-1) hdr.push(''); });
        ws.getRow(currentRow).values = hdr;

        // Fila totales de equipo
        const tot = [''];
        teams.forEach((t,i)=>{
          tot.push(t.name); tot.push(t.points); tot.push(teamTotals[i].scratches); tot.push(teamTotals[i].palos); tot.push(teamTotals[i].aces);
          if(i<teams.length-1) tot.push('');
        });
        ws.getRow(currentRow+1).values = tot;

        // Estilos cabeceras y totales
        let col=2; teams.forEach((t,ti)=>{
          for(let i=0;i<5;i++){
            const c=ws.getCell(currentRow, col+i);
            c.font={bold:false,size:13}; c.alignment={horizontal:'center',vertical:'center'};
            c.border={top:{style:'thin'},left:{style:'thin'},bottom:{style:'thin'},right:{style:'thin'}};
          }
          for(let i=0;i<5;i++){
            const c=ws.getCell(currentRow+1, col+i);
            if(i===0){
              c.fill={type:'pattern',pattern:'solid',fgColor:{argb:t.colors.bg.replace('#','FF')}};
              c.font={color:{argb:t.colors.fg.replace('#','FF')},bold:true,size:14};
            } else if (i===1){ c.font={bold:true,size:12}; }
            else { c.font={bold:false,size:12}; }
            c.alignment={horizontal:'center',vertical:'center'};
            c.border={top:{style:'thin'},left:{style:'thin'},bottom:{style:'thin'},right:{style:'thin'}};
          }
          col += (ti<teams.length-1)?6:5;
        });

        // Jugadores (primer dato EN FILA 4 -> currentRow + 3; sin fila fantasma)
        const rStart = currentRow + 3;
        const maxRows = Math.max(...teams.map(t=>t.players.length));
        for(let i=0;i<maxRows;i++){
          const r = rStart + i;
          const hasAny = teams.some(t=>i<t.players.length); if(!hasAny) continue;
          const row=[''];
          teams.forEach((t,ti)=>{
            const p=t.players[i];
            if (p){
              // 0 como vac√≠o salvo: puntos=0 de jugador presente -> mostrar 0; totales de equipo ya van arriba
              row.push(p.name);
              row.push(p.absent ? '' : (p.points===0 ? 0 : p.points));
              row.push(p.absent ? '' : (p.scratches===0 ? '' : p.scratches));
              row.push(p.absent ? '' : (p.palos===0 ? '' : p.palos));
              row.push(p.absent ? '' : (p.aces===0 ? '' : p.aces));
            } else {
              row.push('','','','','');
            }
            if (ti<teams.length-1) row.push('');
          });
          ws.getRow(r).values = row;

          let c=2; teams.forEach((t,ti)=>{
            const p=t.players[i];
            if (p){
              for(let j=0;j<5;j++){
                const cell=ws.getCell(r, c+j);
                cell.border={top:{style:'thin'},left:{style:'thin'},bottom:{style:'thin'},right:{style:'thin'}};
                cell.alignment={horizontal: j===0?'left':'center', vertical:'center'};
              }
            }
            c += (ti<teams.length-1)?6:5;
          });
        }

        // Anchos (margen 27px; NOMBRE 121px; n√∫meros compactos)
        if (currentRow === 1){
          const tcount=teams.length;
          const widths=[w(27)];
          for(let i=0;i<tcount;i++){
            widths.push(w(121), w(35), w(35), w(35), w(35)); // NOMBRE + 4 num
            if(i<tcount-1) widths.push(w(42)); // separador
          }
          ws.columns = widths.map(W => ({ width: W }));
          addFraming(ws, widths[0]);
        }

        // Siguiente bloque: fin de datos + 2 filas en blanco
        currentRow = (currentRow + 3 + maxRows) + 2;
      });
    }

    /*****************
     * CONSTRUCCI√ìN HOJAS ‚Äî GP (Jornada)
     *****************/
    function buildGPSheet(ws, groups){
      const W_MARGIN = w(27), W_NAME = w(121), W_NUM = w(56), W_SEP = w(42);
      ws.columns = [
        { width: W_MARGIN },
        // Bloque izq (6 cols)
        { width: W_NAME }, { width: W_NUM }, { width: W_NUM }, { width: W_NUM }, { width: W_NUM }, { width: W_NUM },
        // 4 columnas de separaci√≥n
        { width: W_SEP }, { width: W_SEP }, { width: W_SEP }, { width: W_SEP },
        // Bloque der (6 cols)
        { width: W_NAME }, { width: W_NUM }, { width: W_NUM }, { width: W_NUM }, { width: W_NUM }, { width: W_NUM }
      ];
      ws.views = [{ showGridLines: false }];

      const BAR_COLOR = 'FF16A085'; // tono fuerte
      const WHITE = 'FFFFFFFF';

      let baseRow = 2;
      for (let gi = 0; gi < groups.length; gi += 2){
        const left = groups[gi];
        const right = groups[gi+1];

        // Barra superior por grupo
        if (left){
          ws.mergeCells(baseRow, 2, baseRow, 7);
          const c = ws.getCell(baseRow, 2);
          c.value = left.group;
          c.font = { bold:true, size:13, color:{argb:WHITE} };
          c.alignment = { horizontal:'center' };
          c.fill = { type:'pattern', pattern:'solid', fgColor:{argb:BAR_COLOR} };
        }
        if (right){
          ws.mergeCells(baseRow, 12, baseRow, 17);
          const c = ws.getCell(baseRow, 12);
          c.value = right.group;
          c.font = { bold:true, size:13, color:{argb:WHITE} };
          c.alignment = { horizontal:'center' };
          c.fill = { type:'pattern', pattern:'solid', fgColor:{argb:BAR_COLOR} };
        }

        // Encabezados fila inferior: primera celda = ‚ÄúGRUPO ‚Ä¶‚Äù
        const head = baseRow + 1;
        if (left){
          const arr = [left.group, 'GPP','PTS','POS','SCR','ACE'];
          for (let i=0;i<6;i++){
            const cell = ws.getCell(head, 2 + i);
            cell.value = arr[i];
            cell.font = { bold:true, color:{argb:WHITE} };
            cell.alignment = { horizontal:'center' };
            cell.fill = { type:'pattern', pattern:'solid', fgColor:{argb:BAR_COLOR} };
          }
        }
        if (right){
          const arr = [right.group, 'GPP','PTS','POS','SCR','ACE'];
          for (let i=0;i<6;i++){
            const cell = ws.getCell(head, 12 + i);
            cell.value = arr[i];
            cell.font = { bold:true, color:{argb:WHITE} };
            cell.alignment = { horizontal:'center' };
            cell.fill = { type:'pattern', pattern:'solid', fgColor:{argb:BAR_COLOR} };
          }
        }

        const render = (g, c0) => {
          if (!g) return 0;
          const present = g.players.filter(p=>p.present).sort((a,b)=> b.pts - a.pts);
          const absent  = g.players.filter(p=>!p.present);
          const ordered = [...present, ...absent];
          let r = head + 1;
          ordered.forEach(p=>{
            ws.getCell(r, c0+0).value = p.name;
            ws.getCell(r, c0+0).alignment = { horizontal:'left' };
            ws.getCell(r, c0+1).value = p.present ? p.gpp : 0;
            ws.getCell(r, c0+1).font  = { bold:true }; // GPP en negrita
            ws.getCell(r, c0+2).value = p.present ? p.pts : 0;
            ws.getCell(r, c0+3).value = p.present ? p.pos : 0;
            ws.getCell(r, c0+4).value = p.present ? p.scr : 0;
            ws.getCell(r, c0+5).value = p.present ? p.aces : 0;
            for (let k=1;k<=5;k++) ws.getCell(r, c0+k).alignment = { horizontal:'center' };
            r++;
          });
          return ordered.length;
        };

        const rowsLeft  = render(left, 2);
        const rowsRight = render(right, 12);
        baseRow += 2 + Math.max(rowsLeft, rowsRight) + 2; // aire entre parejas
      }

      // Marco fino
      ws.spliceRows(1, 0, []); try{ ws.getRow(1).height = 7.5; }catch{}
      ws.addRow([]); try{ ws.getRow(ws.lastRow.number).height = 7.5; }catch{}
      ws.columns = [...ws.columns, { width: ws.columns[0].width }];
    }

    /*****************
     * TOTALES / MEDIAS (LIGA)
     *****************/
    // 1) Leer ‚ÄúEstad√≠sticas‚Äù de cada Excel de jornada
    function findHeaderStartCol(row){
      const n = row.actualCellCount || row.cellCount || 80;
      for (let c=1;c<=n;c++){
        const v = norm(row.getCell(c).value);
        const nxt = norm(row.getCell(c+1).value);
        if ((v==='PUNTOS' || v==='PUNT.' || v==='PUNTOS ') && (nxt==='SCRATCHES' || nxt==='SCR')) return c;
      }
      return -1;
    }
    function extractDataFromExcel(worksheet){
      const matches = []; let r=1, maxR = worksheet.rowCount || 2000;
      while (r<=maxR){
        const row = worksheet.getRow(r);
        const startCol = findHeaderStartCol(row);
        if (startCol!==-1){
          const m = extractSingleMatch(worksheet, r, startCol);
          if (m) matches.push(m);
          r += 14; // salto est√°ndar por bloque
        } else { r++; }
      }
      return matches;
    }
    function extractSingleMatch(ws, startRow, startCol){
      try{
        const teamRow = ws.getRow(startRow + 1);
        const teams = {}; const teamOrder = []; const players = [];
        let col = Math.max(1, startCol - 1);
        const maxC = ws.columnCount || 60;
        while (col <= maxC){
          const teamName = xlsToString(teamRow.getCell(col).value).trim();
          if (!teamName) break;
          const teamPoints = numOrNull(teamRow.getCell(col + 1).value);
          teams[teamName] = teamPoints ?? 0; teamOrder.push(teamName);
          for (let rr = startRow + 2; rr < startRow + 12; rr++){
            const row = ws.getRow(rr);
            const name = xlsToString(row.getCell(col).value).trim();
            if (!name) continue;
            const pPoints = numOrNull(row.getCell(col + 1).value);
            const pScr    = numOrNull(row.getCell(col + 2).value) ?? 0;
            const pPalos  = numOrNull(row.getCell(col + 3).value) ?? 0;
            const pAces   = numOrNull(row.getCell(col + 4).value) ?? 0;
            const absent = (pPoints === null);
            players.push({ name: name.toUpperCase(), team: teamName, points: absent ? null : pPoints, scratches: absent ? 0 : pScr, palos: absent ? 0 : pPalos, aces: absent ? 0 : pAces, absent });
          }
          col += 6;
        }
        return { teams, teamOrder, players };
      }catch(e){ console.error('extractSingleMatch error', e); return null; }
    }

    // 2) Construir hoja Totales (ancho margen 27px; NOMBRE 121px; TOT/JUG/AVG/SCO 35px; separadores incluidos)
    function generateTotalsSheet(ws){
      const playerTotals = {}; const teamTotals = {};
      function awardSco(a, b){ if (a > b) return [3,1]; if (a < b) return [1,3]; return [2,2]; }

      // Acumula por partido
      processedData.forEach(match => {
        match.teamOrder.forEach(teamName => {
          if (!teamTotals[teamName]) teamTotals[teamName] = { name:teamName, totalPoints:0,totalPalos:0,totalScratches:0,totalAces:0,totalAsistencia:0,gamesPlayed:0, scoPuntos:0, scoScratches:0 };
        });

        // SCO Puntos
        if (match.teamOrder.length >= 2){
          const A = match.teamOrder[0], B = match.teamOrder[1];
          const pA = +(match.teams[A] || 0), pB = +(match.teams[B] || 0);
          const [sA, sB] = awardSco(pA, pB);
          teamTotals[A].scoPuntos += sA; teamTotals[B].scoPuntos += sB;
        }

        const scratchesByTeam = {};
        match.teamOrder.forEach(teamName => {
          teamTotals[teamName].totalPoints += match.teams[teamName] || 0;
          const teamPlayers = match.players.filter(p=>p.team===teamName && !p.absent);
          teamTotals[teamName].totalAsistencia += teamPlayers.length;
          teamTotals[teamName].gamesPlayed += 1;
          let scrSum = 0;
          teamPlayers.forEach(p=>{
            teamTotals[teamName].totalPalos += p.palos||0;
            teamTotals[teamName].totalScratches += p.scratches||0; scrSum += p.scratches||0;
            teamTotals[teamName].totalAces += p.aces||0;
          });
          scratchesByTeam[teamName] = scrSum;
        });

        // SCO Scratches
        if (match.teamOrder.length >= 2){
          const A = match.teamOrder[0], B = match.teamOrder[1];
          const sA = scratchesByTeam[A] || 0, sB = scratchesByTeam[B] || 0;
          const [sa, sb] = awardSco(sA, sB);
          teamTotals[A].scoScratches += sa; teamTotals[B].scoScratches += sb;
        }

        // Jugadores
        match.players.forEach(p=>{
          if (!p.absent){
            if (!playerTotals[p.name]) playerTotals[p.name] = { name:p.name, team:p.team, totalPoints:0,totalPalos:0,totalScratches:0,totalAces:0,gamesPlayed:0 };
            const rec = playerTotals[p.name];
            rec.team=p.team; rec.totalPoints += p.points||0; rec.totalPalos += p.palos||0; rec.totalScratches += p.scratches||0; rec.totalAces += p.aces||0; rec.gamesPlayed += 1;
          }
        });
      });

      const players = Object.values(playerTotals).map(p=>({ ...p,
        avgPoints: p.gamesPlayed? p.totalPoints/p.gamesPlayed:0,
        avgPalos: p.gamesPlayed? p.totalPalos/p.gamesPlayed:0,
        avgScratches: p.gamesPlayed? p.totalScratches/p.gamesPlayed:0,
        avgAces: p.gamesPlayed? p.totalAces/p.gamesPlayed:0 }));

      const teams = Object.values(teamTotals).map(t=>({ ...t,
        avgPoints: t.gamesPlayed? t.totalPoints/t.gamesPlayed:0,
        avgPalos: t.gamesPlayed? t.totalPalos/t.gamesPlayed:0,
        avgScratches: t.gamesPlayed? t.totalScratches/t.gamesPlayed:0,
        avgAces: t.gamesPlayed? t.totalAces/t.gamesPlayed:0,
        avgAsistencia: t.gamesPlayed? t.totalAsistencia/t.gamesPlayed:0 }));

      function getTeamColors(teamName){ return COLORES_EQUIPOS[teamName] || { bg:'#000000', fg:'#FFFFFF' }; }

      // Orden: si hay SCO ‚Üí SCO desc, luego TOT desc, luego AVG desc; si no hay SCO ‚Üí TOT desc, luego AVG desc
      const sortBy = (items, getter, hasSco=false) => {
        return [...items].sort((a,b)=>{
          const ax = getter(a), bx = getter(b);
          if (hasSco){
            if ((bx.sco||0)!==(ax.sco||0)) return (bx.sco||0)-(ax.sco||0);
            if (bx.tot!==ax.tot) return bx.tot-ax.tot;
            return (bx.avg||0)-(ax.avg||0);
          } else {
            if (bx.tot!==ax.tot) return bx.tot-ax.tot;
            return (bx.avg||0)-(ax.avg||0);
          }
        });
      };

      // === BLOQUES DE JUGADORES === (arrancan en fila 1 t√≠tulo, fila 2 cabecera, fila 4 primer dato ‚Üí sin fila vac√≠a)
      const pBlocks = [
        { title:'PUNTOS',     baseCol:2,  pick:(p)=>({ tot:p.totalPoints, jug:p.gamesPlayed, avg:+p.avgPoints.toFixed(1) }) },
        { title:'POSTES',     baseCol:7,  pick:(p)=>({ tot:p.totalPalos, jug:p.gamesPlayed, avg:+p.avgPalos.toFixed(1) }) },
        { title:'SCRATCHES',  baseCol:12, pick:(p)=>({ tot:p.totalScratches, jug:p.gamesPlayed, avg:+p.avgScratches.toFixed(1) }) },
        { title:'ACES',       baseCol:17, pick:(p)=>({ tot:p.totalAces, jug:p.gamesPlayed, avg:+p.avgAces.toFixed(1) }) }
      ];

      // Encabezados
      pBlocks.forEach(b=>{
        ws.getCell(1, b.baseCol+2).value = b.title;
        ws.getCell(2, b.baseCol+0).value = 'NOMBRE';
        ws.getCell(2, b.baseCol+1).value = 'TOT'; ws.getCell(2, b.baseCol+1).alignment={horizontal:'right'};
        ws.getCell(2, b.baseCol+2).value = 'JUG'; ws.getCell(2, b.baseCol+2).alignment={horizontal:'right'};
        ws.getCell(2, b.baseCol+3).value = 'AVG'; ws.getCell(2, b.baseCol+3).alignment={horizontal:'right'};
        // Centrar el ‚ÄúSCRATCHES‚Äù del bloque correspondiente (el texto del t√≠tulo ya va centrado por defecto)
        if (b.title==='SCRATCHES'){ ws.getCell(1, b.baseCol+2).alignment = { horizontal:'center' }; }
      });

      const sortedByPoints = sortBy(players, p => ({tot:p.totalPoints, avg:+p.avgPoints.toFixed(1)}), false);
      const topOrder = sortedByPoints.map(p=>p.name); // orden base de #1..#N (seg√∫n PUNTOS)

      // Relleno de filas: primera fila de datos = 4
      const firstDataRow = 4;
      topOrder.forEach((nick, idx)=>{
        const p = players.find(pp=>pp.name===nick); if(!p) return;
        pBlocks.forEach(b=>{
          const row = firstDataRow + idx;
          const colors = getTeamColors(p.team);
          const nameCell = ws.getCell(row, b.baseCol+0);
          nameCell.value = p.name;
          nameCell.font = { color:{argb: colors.fg.replace('#','FF')} };
          nameCell.fill = { type:'pattern', pattern:'solid', fgColor:{argb: colors.bg.replace('#','FF')} };

          const vals = b.pick(p);
          ws.getCell(row, b.baseCol+1).value = vals.tot; ws.getCell(row, b.baseCol+1).alignment={horizontal:'right'};
          ws.getCell(row, b.baseCol+2).value = vals.jug; ws.getCell(row, b.baseCol+2).alignment={horizontal:'right'};
          ws.getCell(row, b.baseCol+3).value = vals.avg; ws.getCell(row, b.baseCol+3).alignment={horizontal:'right'};
        });
      });

      // Primera columna (margen) con #1..#33 centrado, #1..#10 en negrita (tama√±o un punto menor)
      const leftCol = 1;
      const fontSize = 11; // supuesta base
      for (let i=0;i<Math.min(33, topOrder.length); i++){
        const row = firstDataRow + i;
        const c = ws.getCell(row, leftCol);
        c.value = `#${i+1}`;
        c.alignment = { horizontal:'center' };
        c.font = { bold: i<10, size: fontSize-1 };
      }
      // Inserta DOS filas finas tras el #33 (si hay m√°s de 33)
      if (topOrder.length > 33){
        const cutRow = firstDataRow + 33; // fila despu√©s de #33
        ws.spliceRows(cutRow, 0, [], []);
        try{ ws.getRow(cutRow).height = 7.5; ws.getRow(cutRow+1).height = 7.5; }catch{}
      }

      // === BLOQUES DE EQUIPOS ===
      const tBlocks = [
        { title:'PUNTOS',     baseCol:24, hasSco:true,  getter:(t)=>({ sco:t.scoPuntos||0, tot:t.totalPoints,    avg:+t.avgPoints.toFixed(1) }) },
        { title:'POSTES',     baseCol:30, hasSco:false, getter:(t)=>({               tot:t.totalPalos,     avg:+t.avgPalos.toFixed(1) }) },
        { title:'SCRATCHES',  baseCol:35, hasSco:true,  getter:(t)=>({ sco:t.scoScratches||0, tot:t.totalScratches, avg:+t.avgScratches.toFixed(1) }) },
        { title:'ACES',       baseCol:41, hasSco:false, getter:(t)=>({               tot:t.totalAces,      avg:+t.avgAces.toFixed(1) }) },
        { title:'ASISTENCIA', baseCol:46, hasSco:false, getter:(t)=>({               tot:t.totalAsistencia,avg:+t.avgAsistencia.toFixed(1) }) }
      ];

      tBlocks.forEach(b=>{
        ws.getCell(1, b.baseCol+2).value = b.title;
        ws.getCell(2, b.baseCol+0).value = 'EQUIPO';
        if (b.title==='ASISTENCIA'){ ws.getCell(1, b.baseCol+2).alignment = { horizontal:'center' }; }
        if (b.hasSco){
          ws.getCell(2, b.baseCol+1).value = 'SCO';
          ws.getCell(2, b.baseCol+2).value = 'TOT';
          ws.getCell(2, b.baseCol+3).value = 'JUG';
          ws.getCell(2, b.baseCol+4).value = 'AVG';
          [1,2,3,4].forEach(off=> ws.getCell(2, b.baseCol+off).alignment = { horizontal:'center' });
        }else{
          ws.getCell(2, b.baseCol+1).value = 'TOT';
          ws.getCell(2, b.baseCol+2).value = 'JUG';
          ws.getCell(2, b.baseCol+3).value = 'AVG';
          [1,2,3].forEach(off=> ws.getCell(2, b.baseCol+off).alignment = { horizontal:'center' });
        }

        const sorted = sortBy(teams, b.getter, b.hasSco);
        sorted.forEach((t, idx)=>{
          const row = firstDataRow + idx;
          const colors = getTeamColors(t.name);
          const nameCell = ws.getCell(row, b.baseCol+0);
          nameCell.value = t.name;
          nameCell.font = { color:{ argb: colors.fg.replace('#','FF') } };
          nameCell.fill = { type:'pattern', pattern:'solid', fgColor:{ argb: colors.bg.replace('#','FF') } };

          const vals = b.getter(t);
          let off = 1;
          if (b.hasSco){ ws.getCell(row, b.baseCol+off).value = vals.sco; ws.getCell(row, b.baseCol+off).alignment={horizontal:'center'}; off++; }
          ws.getCell(row, b.baseCol+off).value = vals.tot; ws.getCell(row, b.baseCol+off).alignment={horizontal:'center'}; off++;
          ws.getCell(row, b.baseCol+off).value = teams.find(tt=>tt.name===t.name).gamesPlayed; ws.getCell(row, b.baseCol+off).alignment={horizontal:'center'}; off++;
          ws.getCell(row, b.baseCol+off).value = vals.avg; ws.getCell(row, b.baseCol+off).alignment={horizontal:'center'};
        });
      });

      // Anchos
      ws.columns = [
        { width: w(27) },
        // Jugadores (4 bloques x 4 columnas + separadores)
        { width: w(121) }, { width: w(35) }, { width: w(35) }, { width: w(35) }, { width: w(21) },
        { width: w(121) }, { width: w(35) }, { width: w(35) }, { width: w(35) }, { width: w(21) },
        { width: w(121) }, { width: w(35) }, { width: w(35) }, { width: w(35) }, { width: w(21) },
        { width: w(121) }, { width: w(35) }, { width: w(35) }, { width: w(35) }, { width: w(21) },
        // Separadores extra
        { width: w(21) }, { width: w(21) },
        // Equipos (PUNTOS con SCO)
        { width: w(121) }, { width: w(35) }, { width: w(35) }, { width: w(35) }, { width: w(35) }, { width: w(21) },
        // POSTES
        { width: w(121) }, { width: w(35) }, { width: w(35) }, { width: w(35) }, { width: w(21) },
        // SCRATCHES con SCO
        { width: w(121) }, { width: w(35) }, { width: w(35) }, { width: w(35) }, { width: w(35) }, { width: w(21) },
        // ACES
        { width: w(121) }, { width: w(35) }, { width: w(35) }, { width: w(35) }, { width: w(21) },
        // ASISTENCIA
        { width: w(121) }, { width: w(35) }, { width: w(35) }, { width: w(35) }
      ];
      addFraming(ws, ws.columns[0]?.width || w(27));
    }

    // 3) Hoja ‚ÄúTotales2‚Äù (igual que Totales pero fuente m√°s grande y anchos proporcionales; aqu√≠ solo ajustamos anchos pedidos)
    function generateTotals2Sheet(ws){
      // Reaprovechamos la hoja Totales y luego escalamos fuente/anchos.
      generateTotalsSheet(ws);
      // Aumentar tama√±o de fuente general (ligero)
      ws.eachRow(r => r.eachCell(c => { c.font = { ...(c.font||{}), size: (c.font?.size||11) + 3 }; }));
      // Ajuste de columnas: donde Totales usa 35px, aqu√≠ aprox 44px
      ws.columns.forEach((col, idx)=>{
        // columnas num√©ricas (TOT/JUG/AVG/SCO) est√°n a 35px ‚âà width w(35)
        if (Math.abs(col.width - w(35)) < 0.3) col.width = w(44);
      });
    }

  </script>
</body>
</html>
